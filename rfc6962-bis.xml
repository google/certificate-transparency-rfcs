<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc sortrefs="yes" ?>

<rfc ipr="trust200902" category="std" submissionType="IETF" docName="draft-ietf-trans-rfc6962-bis-18">

  <front>
    <title>Certificate Transparency</title>
    <author initials="B" surname="Laurie" fullname="Ben Laurie">
      <organization abbrev="Google">
        Google UK Ltd.
      </organization>
      <address>
        <email>benl@google.com</email>
      </address>
    </author>
    <author initials="A" surname="Langley" fullname="Adam Langley">
      <organization abbrev="Google">
        Google Inc.
      </organization>
      <address>
        <email>agl@google.com</email>
      </address>
    </author>
    <author initials="E" surname="Kasper" fullname="Emilia Kasper">
      <organization abbrev="Google">
        Google Switzerland GmbH
      </organization>
      <address>
        <email>ekasper@google.com</email>
      </address>
    </author>
    <author initials="E" surname="Messeri" fullname="Eran Messeri">
      <organization abbrev="Google">
        Google UK Ltd.
      </organization>
      <address>
        <email>eranm@google.com</email>
      </address>
    </author>
    <author initials="R" surname="Stradling" fullname="Rob Stradling">
      <organization abbrev="Comodo">
        Comodo CA, Ltd.
      </organization>
      <address>
        <email>rob.stradling@comodo.com</email>
      </address>
    </author>
    <date />
    <workgroup>Public Notary Transparency Working Group</workgroup>

    <abstract>
      <t>
        This document describes a protocol for publicly logging
the existence of Transport Layer Security (TLS) certificates as they are issued
or observed, in a manner that allows anyone to audit certification authority (CA)
activity and notice the issuance of suspect certificates as well as to audit
the certificate logs themselves. The intent is that eventually clients would
refuse to honor certificates that do not appear in a log, effectively forcing
CAs to add all issued certificates to the logs.
      </t>
      <t>
        Logs are network services that implement the protocol operations for
submissions and queries that are defined in this document.
      </t>
    </abstract>
  </front>
  <middle>
    <section title="Introduction">
      <t>
        Certificate transparency aims to mitigate the problem of misissued
certificates by providing append-only logs of issued certificates. The logs
do not need to be trusted because they are publicly auditable. Anyone may verify
the correctness of each log and monitor when new certificates are added to it.
The logs do not themselves prevent misissue, but
they ensure that interested parties (particularly those named in certificates)
can detect such misissuance. Note that this is a general mechanism; but in this
document, we only describe its use for public TLS server certificates issued by
public certification authorities (CAs).
      </t>
      <t>
        Each log contains certificate chains, which can be submitted by anyone. It is expected that public CAs will contribute all their newly issued certificates to one or more logs; however certificate holders can also contribute their own certificate chains, as can third parties. In order to avoid logs being rendered useless by the submission of large numbers of spurious certificates, it is required that each chain ends with a trust anchor that is accepted by the log. When a chain is accepted by a log, a signed timestamp is returned, which can later be used to provide evidence to TLS clients that the chain has been submitted. TLS clients can thus require that all certificates they accept as valid are accompanied by signed timestamps.
      </t>
      <t>
        Those who are concerned about misissuance can monitor the logs, asking
them regularly for all new entries, and can thus check whether domains for which 
they are responsible have had certificates issued that they did not expect. What
they do with this information, particularly when they find that a misissuance
has happened, is beyond the scope of this document; but, broadly speaking, they
can invoke existing business mechanisms for dealing with misissued
certificates, such as working with the CA to get the certificate revoked, or with maintainers of trust anchor lists to get the CA removed. Of course, anyone who wants can monitor the logs and, if they
believe a certificate is incorrectly issued, take action as they see fit.
      </t>
      <t>
        Similarly, those who have seen signed timestamps from a particular log can later demand a proof of inclusion from that log. If the log is unable to provide this (or, indeed, if the corresponding certificate is absent from monitors' copies of that log), that is evidence of the incorrect operation of the log. The checking operation is asynchronous to allow clients to proceed without delay, despite possible issues such as network connectivity and the vagaries of firewalls.
      </t>
      <t>
        The append-only property of each log is achieved using Merkle Trees, which can be used to show that any particular instance of the log is a superset of any particular previous instance. Likewise, Merkle Trees avoid the need to blindly trust logs: if a log attempts to show different things to different people, this can be efficiently detected by comparing tree roots and consistency proofs. Similarly, other misbehaviors of any log (e.g., issuing signed timestamps for certificates they then don't log) can be efficiently detected and proved to the world at large.
      </t>
      <section title="Requirements Language">
        <t>
          The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
        </t>
      </section>
      <section title="Data Structures">
        <t>
          Data structures are defined according to the conventions laid out in
Section 4 of <xref target="RFC5246"/>.
        </t>
      </section>
    </section>
    <section title="Cryptographic Components">
      <section title="Merkle Hash Trees" anchor="mht">
        <t>
          Logs use a binary Merkle Hash Tree for efficient auditing. The hashing algorithm used by each log is expected to be specified as part of the metadata relating to that log (see <xref target="metadata"/>). We have established a registry of acceptable algorithms, see <xref target="hash_algorithms"/>. The hashing algorithm in use is referred to as HASH throughout this document and the size of its output in bytes as HASH_SIZE. The input to the Merkle Tree Hash is a list
of data entries; these entries will be hashed to form the leaves of the Merkle
Hash Tree. The output is a single HASH_SIZE Merkle Tree Hash. Given an ordered
list of n inputs, D[n] = {d(0), d(1), ..., d(n-1)}, the Merkle Tree Hash (MTH)
is thus defined as follows:
        </t>
        <t>
          The hash of an empty list is the hash of an empty string:
          <vspace blankLines='1' />
          MTH({}) = HASH().
          <vspace blankLines='1' />
          The hash of a list with one entry (also known as a leaf hash) is:
          <vspace blankLines='1' />
          MTH({d(0)}) = HASH(0x00 || d(0)).
          <vspace blankLines='1' />
          For n &gt; 1, let k be the largest power of two smaller than n (i.e., k &lt; n &lt;= 2k). The Merkle Tree Hash of an n-element list D[n] is then defined recursively as
          <vspace blankLines='1' />
          MTH(D[n]) = HASH(0x01 || MTH(D[0:k]) || MTH(D[k:n])),
          <vspace blankLines='1' />
          where || is concatenation and D[k1:k2] denotes the list {d(k1), d(k1+1),..., d(k2-1)} of length (k2 - k1). (Note that the hash calculations for leaves and nodes differ. This domain separation is required to give second preimage resistance.)
        </t>
        <t>
          Note that we do not require the length of the input list to be a
power of two. The resulting Merkle Tree may thus not be balanced; however, its
shape is uniquely determined by the number of leaves. (Note: This Merkle Tree is
essentially the same as the <xref target='CrosbyWallach'>history tree</xref>
proposal, except our definition handles non-full trees differently.)
        </t>
      <section title="Merkle Inclusion Proofs" anchor='merkle_inclusion_proof'>
        <t>
          A Merkle inclusion proof for a leaf in a Merkle Hash Tree is the shortest
list of additional nodes in the Merkle Tree required to compute the Merkle Tree
Hash for that tree. Each node in the tree is either a leaf node or is computed
from the two nodes immediately below it (i.e., towards the leaves). At each
step up the tree (towards the root), a node from the inclusion proof is combined
with the node computed so far. In other words, the inclusion proof consists of the
list of missing nodes required to compute the nodes leading from a leaf to the
root of the tree. If the root computed from the inclusion proof matches the true
root, then the inclusion proof proves that the leaf exists in the tree.
        </t>
        <t> Given an ordered list of n inputs to the tree, D[n] = {d(0), ..., d(n-1)}, the Merkle inclusion proof PATH(m, D[n]) for the (m+1)th input d(m), 0 &lt;= m &lt; n, is defined as follows:
        </t>
        <t>
          The proof for the single leaf in a tree with a one-element input list D[1] = {d(0)} is empty:
          <vspace blankLines='1' />
          PATH(0, {d(0)}) = {}
          <vspace blankLines='1' />
          For n &gt; 1, let k be the largest power of two smaller than n. The proof for the (m+1)th element d(m) in a list of n &gt; m elements is then defined recursively as
          <vspace blankLines='1' />
          PATH(m, D[n]) = PATH(m, D[0:k]) : MTH(D[k:n]) for m &lt; k; and
          <vspace blankLines='1' />
          PATH(m, D[n]) = PATH(m - k, D[k:n]) : MTH(D[0:k]) for m &gt;= k,
          <vspace blankLines='1' />
          where : is concatenation of lists and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
        </t>
      </section>

      <section title="Merkle Consistency Proofs" anchor='consistency'>
        <t>
          Merkle consistency proofs prove the append-only property of the tree. A Merkle consistency proof for a Merkle Tree Hash MTH(D[n]) and a previously advertised hash MTH(D[0:m]) of the first m leaves, m &lt;= n, is the list of nodes in the Merkle Tree required to verify that the first m inputs D[0:m] are equal in both trees. Thus, a consistency proof must contain a set of intermediate nodes (i.e., commitments to inputs) sufficient to verify MTH(D[n]), such that (a subset of) the same nodes can be used to verify MTH(D[0:m]). We define an algorithm that outputs the (unique) minimal consistency proof.
        </t>
        <t>
          Given an ordered list of n inputs to the tree, D[n] = {d(0), ..., d(n-1)}, the Merkle consistency proof PROOF(m, D[n]) for a previous Merkle Tree Hash MTH(D[0:m]), 0 &lt; m &lt; n, is defined as:
          <vspace blankLines='1' />
          PROOF(m, D[n]) = SUBPROOF(m, D[n], true)
          <vspace blankLines='1' />
          In SUBPROOF, the boolean value represents whether the subtree created from D[0:m] is a complete subtree of the Merkle Tree created from D[n], and, consequently, whether the subtree Merkle Tree Hash MTH(D[0:m]) is known. The initial call to SUBPROOF sets this to be true, and SUBPROOF is then defined as follows:
          <vspace blankLines='1' />
          The subproof for m = n is empty if m is the value for which PROOF was originally requested (meaning that the subtree created from D[0:m] is a complete subtree of the Merkle Tree created from the original D[n] for which PROOF was requested, and the subtree Merkle Tree Hash MTH(D[0:m]) is known):
          <vspace blankLines='1' />
          SUBPROOF(m, D[m], true) = {}
          <vspace blankLines='1' />
          Otherwise, the subproof for m = n is the Merkle Tree Hash committing inputs D[0:m]:
          <vspace blankLines='1' />
          SUBPROOF(m, D[m], false) = {MTH(D[m])}
          <vspace blankLines='1' />
          For m &lt; n, let k be the largest power of two smaller than n. The subproof is then defined recursively.
          <vspace blankLines='1' />
If m &lt;= k, the right subtree entries D[k:n] only exist in the current tree. We prove that the left subtree entries D[0:k] are consistent and add a commitment to D[k:n]:
          <vspace blankLines='1' />
          SUBPROOF(m, D[n], b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n])
          <vspace blankLines='1' />
If m > k, the left subtree entries D[0:k] are identical in both trees. We prove that the right subtree entries D[k:n] are consistent and add a commitment to D[0:k].
          <vspace blankLines='1' />
          SUBPROOF(m, D[n], b) = SUBPROOF(m - k, D[k:n], false) : MTH(D[0:k])
          <vspace blankLines='1' />
          Here, : is a concatenation of lists, and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
        </t>
        <t>
          The number of nodes in the resulting proof is bounded above by ceil(log2(n)) + 1.
        </t>
      </section>

        <section title="Example">
          <figure>
            <preamble>
              The binary Merkle Tree with 7 leaves:
            </preamble>
            <artwork>
            hash
           /    \
          /      \
         /        \
        /          \
       /            \
      k              l
     / \            / \
    /   \          /   \
   /     \        /     \
  g       h      i      j
 / \     / \    / \     |
 a b     c d    e f     d6
 | |     | |    | |
d0 d1   d2 d3  d4 d5</artwork>
          </figure>
          <t>
            The inclusion proof for d0 is [b, h, l].
          </t>
          <t>
            The inclusion proof for d3 is [c, g, l].
          </t>
          <t>
            The inclusion proof for d4 is [f, j, k].
          </t>
          <t>
            The inclusion proof for d6 is [i, k].
          </t>
          <figure>
            <preamble>
              The same tree, built incrementally in four steps:
            </preamble>
            <artwork>
    hash0          hash1=k
    / \              /  \
   /   \            /    \
  /     \          /      \
  g      c         g       h
 / \     |        / \     / \
 a b     d2       a b     c d
 | |              | |     | |
d0 d1            d0 d1   d2 d3

          hash2                    hash
          /  \                    /    \
         /    \                  /      \
        /      \                /        \
       /        \              /          \
      /          \            /            \
     k            i          k              l
    / \          / \        / \            / \
   /   \         e f       /   \          /   \
  /     \        | |      /     \        /     \
 g       h      d4 d5    g       h      i      j
/ \     / \             / \     / \    / \     |
a b     c d             a b     c d    e f     d6
| |     | |             | |     | |    | |
d0 d1   d2 d3           d0 d1   d2 d3  d4 d5</artwork>
          </figure>
          <t>
            The consistency proof between hash0 and hash is PROOF(3, D[7]) = [c, d, g, l]. c, g are used to verify hash0, and d, l are additionally used to show hash is consistent with hash0.
          </t>
          <t>
            The consistency proof between hash1 and hash is PROOF(4, D[7]) =
[l]. hash can be verified using hash1=k and l.
          </t>
          <t>
            The consistency proof between hash2 and hash is PROOF(6, D[7]) = [i, j, k]. k, i are used to verify hash2, and j is additionally used to show hash is consistent with hash2.
          </t>
        </section>
        <section title="Signatures" anchor="signatures">
          <t>
            Various data structures are signed. A log MUST use one of the signature algorithms defined in the <xref target="signature_algorithms"/>.
          </t>
        </section>
      </section>
    </section>
    <section title="Submitters">
      <t>
        Submitters submit certificates or preannouncements of certificates prior to issuance (precertificates) to logs for public auditing, as described below. In order to enable attribution of each logged certificate or precertificate to its issuer, each submission MUST be accompanied by all additional certificates required to verify the chain up to an accepted trust anchor. The trust anchor (a root or intermediate CA certificate) MAY be omitted from the submission.
      </t>
      <t>
        If a log accepts a submission, it will return a Signed Certificate Timestamp (SCT) (see <xref target="sct"/>). The submitter SHOULD validate the returned SCT as described in <xref target="tls_clients"/> if they understand its format and they intend to use it directly in a TLS handshake or to construct a certificate.  If the submitter does not need the SCT (for example, the certificate is being submitted simply to make it available in the log), it MAY validate the SCT.
      </t>
      <section title="Certificates">
        <t>
          Any entity can <xref target="add-chain">submit a certificate</xref> to a log. Since it is anticipated that TLS clients will reject certificates that are not logged, it is expected that certificate issuers and subjects will be strongly motivated to submit them.
        </t>
      </section>
      <section title="Precertificates" anchor="Precertificates">
        <t>
          CAs may preannounce a certificate prior to issuance by <xref target="add-pre-chain">submitting a precertificate</xref> that the log can use to create an entry that will be valid against the issued certificate. The CA MAY incorporate the returned SCT in the issued certificate. Examples of situations where the returned SCT is not incorporated into the issued certificate would be when a CA sends the precertificate to multiple logs, but only incorporates the SCTs that are returned first, or the CA is using <xref target="domain_name_redaction">domain name redaction</xref> and intends to use another mechanism to publish SCTs (such as an <xref target="ocsp_transinfo_extension">OCSP response</xref> or the <xref target="tls_transinfo_extension">TLS extension</xref>).
        </t>
        <t>
          A precertificate is a CMS <xref target="RFC5652"/> <spanx style="verb">signed-data</spanx> object that conforms to the following requirements:
          <list style="symbols">
            <t>
              It MUST be DER encoded.
            </t>
            <t>
              <spanx style="verb">SignedData.encapContentInfo.eContentType</spanx> MUST be the OID 1.3.101.78.
            </t>
            <t>
              <spanx style="verb">SignedData.encapContentInfo.eContent</spanx> MUST contain a TBSCertificate <xref target="RFC5280"/> that will be identical to the TBSCertificate in the issued certificate, except that:
              <list style="symbols">
                <t>
                  the <xref target="x509v3_transinfo_extension">Transparency Information</xref> extension MUST be omitted.
                </t>
                <t>
                  the <xref target="RFC5280">subjectAltName</xref> extension MUST be omitted when the <xref target="redacted_san_extension">redactedSubjectAltName</xref> extension is present.
                </t>
              </list>
            </t>
            <t>
              <spanx style="verb">SignedData.signerInfos</spanx> MUST contain a signature from the same (root or intermediate) CA that will ultimately issue the certificate. This signature indicates the CA's intent to issue the certificate. This intent is considered binding (i.e. misissuance of the precertificate is considered equivalent to misissuance of the certificate). (Note that, because of the structure of CMS, the signature on the CMS object will not be a valid X.509v3 signature and so cannot be used to construct a certificate from the precertificate).
            </t>
            <t>
              <spanx style="verb">SignedData.certificates</spanx> SHOULD be omitted.
            </t>
          </list>
        </t>
      </section>
    </section>
    <section title="Private Domain Name Labels">
      <t>
        Some regard certain DNS domain name labels within their registered domain space as private and security sensitive. Even though these domains are often only accessible within the domain owner's private network, it's common for them to be secured using publicly trusted TLS server certificates. We define a mechanism (see <xref target="domain_name_redaction"/>) to allow these private labels to not appear in public logs, while still retaining most of the security benefits that accrue from using Certificate Transparency mechanisms.
      </t>
      <section title="Wildcard Certificates">
        <t>
          A certificate containing a <xref target="RFC6125">DNS-ID</xref> of <spanx style="verb">*.example.com</spanx> could be used to secure the domain <spanx style="verb">topsecret.example.com</spanx>, without revealing the string <spanx style="verb">topsecret</spanx> publicly.
        </t>
        <t>
          Since TLS clients only match the wildcard character to the complete leftmost label of the DNS domain name (see Section 6.4.3 of <xref target="RFC6125"/>), a different approach is needed when any label other than the leftmost label in a DNS-ID is considered private (e.g. <spanx style="verb">top.secret.example.com</spanx>). Also, wildcard certificates are prohibited in some cases, such as <xref target="EVSSLGuidelines">Extended Validation Certificates</xref>.
        </t>
      </section>
      <section title="Redaction of Domain Name Labels" anchor="domain_name_redaction">
        <section title="Redacting Labels in Precertificates" anchor="redacting_labels">
          <t>
            When creating a precertificate, the CA MAY omit the subjectAltName extension, even if it intends to include the extension in the final certificate. If omitting the subjectAltName extension, the CA MUST include a <xref target="redacted_san_extension">redactedSubjectAltName</xref> extension that contains, in a redacted form, the same entries that will be included in the certificate's subjectAltName extension.
          </t>
          <figure>
            <preamble>
              Wildcard <spanx style="verb">*</spanx> labels MUST NOT be redacted, but one or more non-wildcard labels in each <xref target="RFC6125">DNS-ID</xref> can each be replaced with a redacted label as follows:
            </preamble>
            <artwork>
  REDACT(label) = prefix || BASE32(index || _label_hash)
    _label_hash = LABELHASH(keyid_len || keyid || label_len || label)</artwork>
          </figure>
          <t>
            <spanx style="verb">label</spanx> is the case-sensitive label to be redacted.
          </t>
          <t>
            <spanx style="verb">prefix</spanx> is the "?" character (ASCII value 63).
          </t>
          <t>
            <spanx style="verb">index</spanx> is the 1 byte index of a hash function in <xref target="hash_algorithms"/>. The value 255 is reserved.
          </t>
          <t>
            <spanx style="verb">keyid_len</spanx> is the 1 byte length of the <spanx style="verb">keyid</spanx>.
          </t>
          <t>
            <spanx style="verb">keyid</spanx> is the keyIdentifier from the Subject Key Identifier extension (section 4.2.1.2 of <xref target="RFC5280"/>), excluding the ASN.1 OCTET STRING tag and length bytes.
          </t>
          <t>
            <spanx style="verb">label_len</spanx> is the 1 byte length of the <spanx style="verb">label</spanx>.
          </t>
          <t>
            <spanx style="verb">||</spanx> denotes concatenation.
          </t>
          <t>
            <spanx style="verb">BASE32</spanx> is the Base 32 Encoding function (section 6 of <xref target="RFC4648"/>). Pad characters MUST NOT be appended to the encoded data.
          </t>
          <t>
            <spanx style="verb">LABELHASH</spanx> is the hash function identified by <spanx style="verb">index</spanx>.
          </t>
        </section>
        <section title="redactedSubjectAltName Certificate Extension" anchor="redacted_san_extension">
          <t>
            The redactedSubjectAltName extension is a non-critical extension (OID 1.3.101.77) that is identical in structure to the subjectAltName extension, except that DNS-IDs MAY contain redacted labels (see <xref target="redacting_labels"/>).
          </t>
          <t>
            When used, the redactedSubjectAltName extension MUST be present in both the precertificate and the corresponding certificate.
          </t>
          <t>
            This extension informs TLS clients of the DNS-ID labels that were redacted and the degree of redaction, while minimizing the complexity of TBSCertificate reconstruction (as described in <xref target="reconstructing_tbscertificate"/>). Hashing the redacted labels allows the legitimate domain owner to identify whether or not each redacted label correlates to a label they know of.
          </t>
          <t>
            Only DNS-ID labels can be redacted using this mechanism. However, CAs can use Name Constraints (<xref target="name_constrained"/>) to allow DNS domain name labels in other subjectAltName entries to not appear in logs.
          </t>
        </section>
      </section>
      <section title="Using a Name-Constrained Intermediate CA" anchor="name_constrained">
        <t>
          An intermediate CA certificate or intermediate CA precertificate that contains the <xref target="RFC5280">Name Constraints</xref> extension MAY be logged in place of end-entity certificates issued by that intermediate CA, as long as all of the following conditions are met:
          <list style="symbols">
            <t>
              there MUST be a non-critical extension (OID 1.3.101.76, whose extnValue OCTET STRING contains ASN.1 NULL data (0x05 0x00)). This extension is an explicit indication that it is acceptable to not log certificates issued by this intermediate CA.
            </t>
            <t>
              permittedSubtrees MUST specify one or more dNSNames.
            </t>
            <t>
              excludedSubtrees MUST specify the entire IPv4 and IPv6 address ranges.
            </t>
          </list>
        </t>
        <figure>
          <preamble>
            Below is an example Name Constraints extension that meets these conditions:
          </preamble>
          <artwork>
    SEQUENCE {
      OBJECT IDENTIFIER '2 5 29 30'
      OCTET STRING, encapsulates {
        SEQUENCE {
          [0] {
            SEQUENCE {
              [2] 'example.com'
              }
            }
          [1] {
            SEQUENCE {
              [7] 00 00 00 00 00 00 00 00
              }
            SEQUENCE {
              [7]
                00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
              }
            }
          }
        }
      }</artwork>
        </figure>
      </section>
    </section>
    <section title="Log Format and Operation">
      <t>
        A log is a single, append-only Merkle Tree of submitted certificate and precertificate entries.
      </t>
      <t>
        When it receives a valid submission, the log MUST return an SCT that corresponds to the submitted certificate or precertificate. If the log has previously seen this valid submission, it SHOULD return the same SCT as it returned before (to reduce the ability to track clients as described in <xref target="deterministic_signatures"/>). If different SCTs are produced for the same submission, multiple log entries will have to be created, one for each SCT (as the timestamp is a part of the leaf structure). Note that if a certificate was previously logged as a precertificate, then the precertificate's SCT of type <spanx style="verb">precert_sct_v2</spanx> would not be appropriate; instead, a fresh SCT of type <spanx style="verb">x509_sct_v2</spanx> should be generated.
      </t>
      <t>
        An SCT is the log's promise to incorporate the submitted entry in its Merkle Tree no later than a fixed amount of time, known as the Maximum Merge Delay (MMD), after the issuance of the SCT. Periodically, the log MUST append all its new entries to its Merkle Tree and sign the root of the tree.
      </t>
      <t>
        Log operators MUST NOT impose any conditions on retrieving or sharing data from the log.
      </t>
      <section title="Accepting Submissions">
        <t>
          Logs MUST verify that each submitted certificate or precertificate has a valid signature chain to an accepted trust anchor, using the chain of intermediate CA certificates provided by the submitter. Logs MUST accept certificates and precertificates that are fully valid according to <xref target="RFC5280">RFC 5280</xref> verification rules and are submitted with such a chain. Logs MAY accept certificates and precertificates that have expired, are not yet valid, have been revoked, or are otherwise not fully valid according to RFC 5280 verification rules in order to accommodate quirks of CA certificate-issuing software. However, logs MUST reject submissions without a valid signature chain to an accepted trust anchor. Logs MUST also reject precertificates that do not conform to the requirements in <xref target="Precertificates"/>.
        </t>
        <t>
          Logs SHOULD limit the length of chain they will accept. The maximum chain length is specified in the log's metadata.
        </t>
        <t>
          The log SHALL allow retrieval of its list of accepted trust anchors (see <xref target="get-anchors"/>), each of which is a root or intermediate CA certificate. This list might usefully be the union of root certificates trusted by major browser vendors.
        </t>
      </section>
      <section title="Log Entries" anchor="log_entries">
        <t>
          If a submission is accepted and an SCT issued, the accepting log MUST store the entire chain used for verification. This chain MUST include the certificate or precertificate itself, the zero or more intermediate CA certificates provided by the submitter, and the trust anchor used to verify the chain (even if it was omitted from the submission). The log MUST present this chain for auditing upon request (see <xref target="get-entries"/>). This chain is required to prevent a CA from avoiding blame by logging a partial or empty chain.
        </t>
        <figure>
          <preamble>
            Each certificate entry in a log MUST include a <spanx style="verb">X509ChainEntry</spanx> structure, and each precertificate entry MUST include a <spanx style="verb">PrecertChainEntryV2</spanx> structure:
          </preamble>
          <artwork>
    opaque ASN.1Cert&lt;1..2^24-1&gt;;

    struct {
        ASN.1Cert leaf_certificate;
        ASN.1Cert certificate_chain&lt;0..2^24-1&gt;;
    } X509ChainEntry;

    opaque CMSPrecert&lt;1..2^24-1&gt;;

    struct {
        CMSPrecert pre_certificate;
        ASN.1Cert precertificate_chain&lt;1..2^24-1&gt;;
    } PrecertChainEntryV2;</artwork>
        </figure>
        <t>
          <spanx style="verb">leaf_certificate</spanx> is a submitted certificate that has been accepted by the log.
        </t>
        <t>
          <spanx style="verb">certificate_chain</spanx> is a vector of 0 or more additional certificates required to verify <spanx style="verb">leaf_certificate</spanx>. The first certificate MUST certify <spanx style="verb">leaf_certificate</spanx>. Each following certificate MUST directly certify the one preceding it. The final certificate MUST be a trust anchor accepted by the log. If <spanx style="verb">leaf_certificate</spanx> is an accepted trust anchor, then this vector is empty.
        </t>
        <t>
          <spanx style="verb">pre_certificate</spanx> is a submitted precertificate that has been accepted by the log.
        </t>
        <t>
          <spanx style="verb">precertificate_chain</spanx> is a vector of 1 or more additional certificates required to verify <spanx style="verb">pre_certificate</spanx>. The first certificate MUST certify <spanx style="verb">pre_certificate</spanx>. Each following certificate MUST directly certify the one preceding it. The final certificate MUST be a trust anchor accepted by the log.
        </t>
      </section>
      <section title="Log ID" anchor="log_id">
        <figure>
          <preamble>
            Each log is identified by an OID, which is specified in the log's metadata and which MUST NOT be used to identify any other log. A log's operator MUST either allocate the OID themselves or request an OID from one of the two Log ID Registries (see <xref target="log_id_registry1"/> and <xref target="log_id_registry2"/>). Various data structures include the DER encoding of this OID, excluding the ASN.1 tag and length bytes, in an opaque vector:
          </preamble>
          <artwork>
    opaque LogID&lt;2..127&gt;;</artwork>
        </figure>
        <t>
          Note that the ASN.1 length and the opaque vector length are identical in size (1 byte) and value, so the DER encoding of the OID can be reproduced simply by prepending an OBJECT IDENTIFIER tag (0x06) to the opaque vector length and contents.
        </t>
      </section>
      <section title="TransItem Structure">
        <figure>
          <preamble>
            Various data structures are encapsulated in the <spanx style="verb">TransItem</spanx> structure to ensure that the type and version of each one is identified in a common fashion:
          </preamble>
          <artwork>
    enum {
        reserved(0),
        x509_entry_v2(1), precert_entry_v2(2),
        x509_sct_v2(3), precert_sct_v2(4),
        tree_head_v2(5), signed_tree_head_v2(6),
        consistency_proof_v2(7), inclusion_proof_v2(8),
        x509_sct_with_proof_v2(9), precert_sct_with_proof_v2(10),
        (65535)
    } VersionedTransType;

    struct {
        VersionedTransType versioned_type;
        select (versioned_type) {
            case x509_entry_v2: TimestampedCertificateEntryDataV2;
            case precert_entry_v2: TimestampedCertificateEntryDataV2;
            case x509_sct_v2: SignedCertificateTimestampDataV2;
            case precert_sct_v2: SignedCertificateTimestampDataV2;
            case tree_head_v2: TreeHeadDataV2;
            case signed_tree_head_v2: SignedTreeHeadDataV2;
            case consistency_proof_v2: ConsistencyProofDataV2;
            case inclusion_proof_v2: InclusionProofDataV2;
            case x509_sct_with_proof_v2: SCTWithProofDataV2;
            case precert_sct_with_proof_v2: SCTWithProofDataV2;
        } data;
    } TransItem;
          </artwork>
        </figure>
        <t>
          <spanx style="verb">versioned_type</spanx> is the type of the encapsulated data structure and the earliest version of this protocol to which it conforms. This document is v2.
        </t>
        <t>
          <spanx style="verb">data</spanx> is the encapsulated data structure. The various structures named with the <spanx style="verb">DataV2</spanx> suffix are defined in later sections of this document.
        </t>
        <t>
          Note that <spanx style="verb">VersionedTransType</spanx> combines the <xref target="RFC6962">v1</xref> type enumerations <spanx style="verb">Version</spanx>, <spanx style="verb">LogEntryType</spanx>, <spanx style="verb">SignatureType</spanx> and <spanx style="verb">MerkleLeafType</spanx>. Note also that v1 did not define <spanx style="verb">TransItem</spanx>, but this document provides guidelines (see <xref target="v1_coexistence"/>) on how v2 implementations can co-exist with v1 implementations.
        </t>
        <t>
          Future versions of this protocol may reuse <spanx style="verb">VersionedTransType</spanx> values defined in this document as long as the corresponding data structures are not modified, and may add new <spanx style="verb">VersionedTransType</spanx> values for new or modified data structures.
        </t>
      </section>
      <section title="Merkle Tree Leaves" anchor="tree_leaves">
        <figure>
          <preamble>
            The leaves of a log's Merkle Tree correspond to the log's entries (see <xref target="log_entries"/>). Each leaf is the <xref target="mht">leaf hash</xref> of a <spanx style="verb">TransItem</spanx> structure of type <spanx style="verb">x509_entry_v2</spanx> or <spanx style="verb">precert_entry_v2</spanx>, which encapsulates a <spanx style="verb">TimestampedCertificateEntryDataV2</spanx> structure. Note that leaf hashes are calculated as HASH(0x00 || TransItem), where the hashing algorithm is specified in the log's metadata.
          </preamble>
          <artwork>
    opaque TBSCertificate&lt;1..2^24-1&gt;;

    struct {
        uint64 timestamp;
        opaque issuer_key_hash[HASH_SIZE];
        TBSCertificate tbs_certificate;
        SctExtension sct_extensions&lt;0..2^16-1&gt;;
    } TimestampedCertificateEntryDataV2;</artwork>
        </figure>
        <t>
          <spanx style="verb">timestamp</spanx> is the <xref target="RFC5905">NTP Time</xref> at which the certificate or precertificate was accepted by the log, measured in milliseconds since the epoch (January 1, 1970, 00:00), ignoring leap seconds. Note that the leaves of a log's Merkle Tree are not required to be in strict chronological order.
        </t>
        <t>
          <spanx style="verb">issuer_key_hash</spanx> is the HASH of the public key of the CA that issued the certificate or precertificate, calculated over the DER encoding of the key represented as <xref target="RFC5280">SubjectPublicKeyInfo</xref>. This is needed to bind the CA to the certificate or precertificate, making it impossible for the corresponding SCT to be valid for any other certificate or precertificate whose TBSCertificate matches <spanx style="verb">tbs_certificate</spanx>.
        </t>
        <t>
          <spanx style="verb">tbs_certificate</spanx> is the DER encoded TBSCertificate from either the <spanx style="verb">leaf_certificate</spanx> (in the case of an <spanx style="verb">X509ChainEntry</spanx>) or the <spanx style="verb">pre_certificate</spanx> (in the case of a <spanx style="verb">PrecertChainEntryV2</spanx>). (Note that a precertificate's TBSCertificate can be reconstructed from the corresponding certificate as described in <xref target="reconstructing_tbscertificate"/>).
        </t>
        <t>
          <spanx style="verb">sct_extensions</spanx> matches the SCT extensions of the corresponding SCT.
        </t>
      </section>
      <section title="Signed Certificate Timestamp (SCT)" anchor="sct">
        <figure>
          <preamble>
            An SCT is a <spanx style="verb">TransItem</spanx> structure of type <spanx style="verb">x509_sct_v2</spanx> or <spanx style="verb">precert_sct_v2</spanx>, which encapsulates a <spanx style="verb">SignedCertificateTimestampDataV2</spanx> structure:
          </preamble>
          <artwork>
    enum {
        reserved(65535)
    } SctExtensionType;

    struct {
        SctExtensionType sct_extension_type;
        opaque sct_extension_data&lt;0..2^16-1&gt;;
    } SctExtension;

    struct {
        LogID log_id;
        uint64 timestamp;
        SctExtension sct_extensions&lt;0..2^16-1&gt;;
        digitally-signed struct {
            TransItem timestamped_entry;
        } signature;
    } SignedCertificateTimestampDataV2;</artwork>
        </figure>
        <t>
          <spanx style="verb">log_id</spanx> is this log's unique ID, encoded in an opaque vector as described in <xref target="log_id"/>.
        </t>
        <t>
          <spanx style="verb">timestamp</spanx> is equal to the timestamp from the <spanx style="verb">TimestampedCertificateEntryDataV2</spanx> structure encapsulated in the <spanx style="verb">timestamped_entry</spanx>.
        </t>
        <t>
          <spanx style="verb">sct_extension_type</spanx> identifies a single extension from the IANA registry in <xref target="sct_extension_types"/>. At the time of writing, no extensions are specified.
        </t>
        <t>
          The interpretation of the <spanx style="verb">sct_extension_data</spanx> field is determined solely by the value of the <spanx style="verb">sct_extension_type</spanx> field. Each document that registers a new <spanx style="verb">sct_extension_type</spanx> must describe how to interpret the corresponding <spanx style="verb">sct_extension_data</spanx>.
        </t>
        <t>
          <spanx style="verb">sct_extensions</spanx> is a vector of 0 or more SCT extensions. This vector MUST NOT include more than one extension with the same <spanx style="verb">sct_extension_type</spanx>. The extensions in the vector MUST be ordered by the value of the <spanx style="verb">sct_extension_type</spanx> field, smallest value first. If an implementation sees an extension that it does not understand, it SHOULD ignore that extension. Furthermore, an implementation MAY choose to ignore any extension(s) that it does understand.
        </t>
        <t>
          The encoding of the digitally-signed element is defined in <xref target='RFC5246'/>.
        </t>
        <t>
          <spanx style="verb">timestamped_entry</spanx> is a <spanx style="verb">TransItem</spanx> structure that MUST be of type <spanx style="verb">x509_entry_v2</spanx> or <spanx style="verb">precert_entry_v2</spanx> (see <xref target="tree_leaves"/>).
        </t>
      </section>
      <section title="Merkle Tree Head" anchor="tree_head">
        <figure>
          <preamble>
            The log stores information about its Merkle Tree in a <spanx style="verb">TransItem</spanx> structure of type <spanx style="verb">tree_head_v2</spanx>, which encapsulates a <spanx style="verb">TreeHeadDataV2</spanx> structure:
          </preamble>
          <artwork>
    opaque NodeHash[HASH_SIZE];

    struct {
        uint64 timestamp;
        uint64 tree_size;
        NodeHash root_hash;
        SthExtension sth_extensions&lt;0..2^16-1&gt;;
    } TreeHeadDataV2;</artwork>
        </figure>
        <t>
          <spanx style="verb">timestamp</spanx> is the current <xref target="RFC5905">NTP Time</xref>, measured in milliseconds since the epoch (January 1, 1970, 00:00), ignoring leap seconds.
        </t>
        <t>
          <spanx style="verb">tree_size</spanx> is the number of entries currently in the log's Merkle Tree.
        </t>
        <t>
          <spanx style="verb">root_hash</spanx> is the root of the Merkle Hash Tree.
        </t>
        <t>
          <spanx style="verb">sth_extensions</spanx> matches the STH extensions of the corresponding STH.
        </t>
      </section>
      <section title="Signed Tree Head (STH)" anchor="STH">
        <t>
          Periodically each log SHOULD sign its current tree head information (see <xref target="tree_head"/>) to produce an STH. When a client requests a log's latest STH (see <xref target="get-sth"/>), the log MUST return an STH that is no older than the log's MMD. However, STHs could be used to mark individual clients (by producing a new one for each query), so logs MUST NOT produce them more frequently than is declared in their metadata. In general, there is no need to produce a new STH unless there are new entries in the log; however, in the unlikely event that it receives no new submissions during an MMD period, the log SHALL sign the same Merkle Tree Hash with a fresh timestamp.
        </t>
        <figure>
          <preamble>
            An STH is a <spanx style="verb">TransItem</spanx> structure of type <spanx style="verb">signed_tree_head_v2</spanx>, which encapsulates a <spanx style="verb">SignedTreeHeadDataV2</spanx> structure:
          </preamble>
          <artwork>
    enum {
        reserved(65535)
    } SthExtensionType;

    struct {
        SthExtensionType sth_extension_type;
        opaque sth_extension_data&lt;0..2^16-1&gt;;
    } SthExtension;

    struct {
        LogID log_id;
        uint64 timestamp;
        uint64 tree_size;
        NodeHash root_hash;
        SthExtension sth_extensions&lt;0..2^16-1&gt;;
        digitally-signed struct {
            TransItem merkle_tree_head;
        } signature;
    } SignedTreeHeadDataV2;</artwork>
        </figure>
        <t>
          <spanx style="verb">log_id</spanx> is this log's unique ID, encoded in an opaque vector as described in <xref target="log_id"/>.
        </t>
        <t>
          <spanx style="verb">timestamp</spanx> is equal to the timestamp from the <spanx style="verb">TreeHeadDataV2</spanx> structure encapsulated in <spanx style="verb">merkle_tree_head</spanx>. This timestamp MUST be at least as recent as the most recent SCT timestamp in the tree. Each subsequent timestamp MUST be more recent than the timestamp of the previous update.
        </t>
        <t>
          <spanx style="verb">tree_size</spanx> is equal to the tree size from the <spanx style="verb">TreeHeadDataV2</spanx> structure encapsulated in <spanx style="verb">merkle_tree_head</spanx>.
        </t>
        <t>
          <spanx style="verb">root_hash</spanx> is equal to the root hash from the <spanx style="verb">TreeHeadDataV2</spanx> structure encapsulated in <spanx style="verb">merkle_tree_head</spanx>.
        </t>
        <t>
          <spanx style="verb">sth_extension_type</spanx> identifies a single extension from the IANA registry in <xref target="sth_extension_types"/>. At the time of writing, no extensions are specified.
        </t>
        <t>
          The interpretation of the <spanx style="verb">sth_extension_data</spanx> field is determined solely by the value of the <spanx style="verb">sth_extension_type</spanx> field. Each document that registers a new <spanx style="verb">sth_extension_type</spanx> must describe how to interpret the corresponding <spanx style="verb">sth_extension_data</spanx>.
        </t>
        <t>
          <spanx style="verb">sth_extensions</spanx> is a vector of 0 or more STH extensions. This vector MUST NOT include more than one extension with the same <spanx style="verb">sth_extension_type</spanx>. The extensions in the vector MUST be ordered by the value of the <spanx style="verb">sth_extension_type</spanx> field, smallest value first. If an implementation sees an extension that it does not understand, it SHOULD ignore that extension. Furthermore, an implementation MAY choose to ignore any extension(s) that it does understand.
        </t>
        <t>
          <spanx style="verb">merkle_tree_head</spanx> is a <spanx style="verb">TransItem</spanx> structure that MUST be of type <spanx style="verb">tree_head_v2</spanx> (see <xref target="tree_head"/>).
        </t>
      </section>
      <section title="Merkle Consistency Proofs">
        <figure>
          <preamble>
            To prepare a Merkle Consistency Proof for distribution to clients, the log produces a <spanx style="verb">TransItem</spanx> structure of type <spanx style="verb">consistency_proof_v2</spanx>, which encapsulates a <spanx style="verb">ConsistencyProofDataV2</spanx> structure:
          </preamble>
          <artwork>
    struct {
        LogID log_id;
        uint64 tree_size_1;
        uint64 tree_size_2;
        NodeHash consistency_path&lt;1..2^8-1&gt;;
    } ConsistencyProofDataV2;</artwork>
        </figure>
        <t>
          <spanx style="verb">log_id</spanx> is this log's unique ID, encoded in an opaque vector as described in <xref target="log_id"/>.
        </t>
        <t>
          <spanx style="verb">tree_size_1</spanx> is the size of the older tree.
        </t>
        <t>
          <spanx style="verb">tree_size_2</spanx> is the size of the newer tree.
        </t>
        <t>
          <spanx style="verb">consistency_path</spanx> is a vector of Merkle Tree nodes proving the consistency of two STHs.
        </t>
      </section>
      <section title="Merkle Inclusion Proofs">
        <figure>
          <preamble>
            To prepare a Merkle Inclusion Proof for distribution to clients, the log produces a <spanx style="verb">TransItem</spanx> structure of type <spanx style="verb">inclusion_proof_v2</spanx>, which encapsulates an <spanx style="verb">InclusionProofDataV2</spanx> structure:
          </preamble>
          <artwork>
    struct {
        LogID log_id;
        uint64 tree_size;
        uint64 leaf_index;
        NodeHash inclusion_path&lt;1..2^8-1&gt;;
    } InclusionProofDataV2;</artwork>
        </figure>
        <t>
          <spanx style="verb">log_id</spanx> is this log's unique ID, encoded in an opaque vector as described in <xref target="log_id"/>.
        </t>
        <t>
          <spanx style="verb">tree_size</spanx> is the size of the tree on which this inclusion proof is based.
        </t>
        <t>
          <spanx style="verb">leaf_index</spanx> is the 0-based index of the log entry corresponding to this inclusion proof.
        </t>
        <t>
          <spanx style="verb">inclusion_path</spanx> is a vector of Merkle Tree nodes proving the inclusion of the chosen certificate or precertificate.
        </t>
      </section>
      <section title="Shutting down a log">
        <t>
          Log operators may decide to shut down a log for various reasons, such as deprecation of the signature algorithm. If there are entries in the log for certificates that have not yet expired, simply making TLS clients stop recognizing that log will have the effect of invalidating SCTs from that log. To avoid that, the following actions are suggested:
          <list style="symbols">
            <t>Make it known to clients and monitors that the log will be frozen.</t>
            <t>Stop accepting new submissions (the error code "shutdown" should be returned for such requests).</t>
            <t>Once MMD from the last accepted submission has passed and all pending submissions are incorporated, issue a final STH and publish it as a part of the log's metadata. Having an STH with a timestamp that is after the MMD has passed from the last SCT issuance allows clients to audit this log regularly without special handling for the final STH. At this point the log's private key is no longer needed and can be destroyed.</t>
            <t>Keep the log running until the certificates in all of its entries have expired or exist in other logs (this can be determined by scanning other logs or connecting to domains mentioned in the certificates and inspecting the SCTs served).</t>
          </list>
        </t>
      </section>
    </section>
    <section title="Log Client Messages" anchor="client_messages">
      <t>
        Messages are sent as HTTPS GET or POST requests. Parameters for POSTs
and all responses are encoded as <xref target="RFC4627">JavaScript Object
Notation (JSON)
objects</xref>. Parameters for GETs are encoded as order-independent key/value
URL parameters, using the "application/x-www-form-urlencoded" format described
in the <xref target="HTML401">"HTML 4.01 Specification"</xref>. Binary data is
<xref target="RFC4648">base64 encoded</xref> as specified in the individual
messages.
      </t>
      <t>
        Note that JSON objects and URL parameters may contain fields not specified here. These extra fields should be ignored.
      </t>
      <t>
        The &lt;log server&gt; prefix, which is part of the log's metadata, MAY include a path as well as a server name and a port.
      </t>
      <t>
        In practice, log servers may include multiple front-end machines. Since it is impractical to keep these machines in perfect sync, errors may occur that are caused by skew between the machines. Where such errors are possible, the front-end will return additional information (as specified below) making it possible for clients to make progress, if progress is possible. Front-ends MUST only serve data that is free of gaps (that is, for example, no front-end will respond with an STH unless it is also able to prove consistency from all log entries logged within that STH).
      </t>
      <t>
        For example, when a consistency proof between two STHs is requested, the front-end reached may not yet be aware of one or both STHs. In the case where it is unaware of both, it will return the latest STH it is aware of. Where it is aware of the first but not the second, it will return the latest STH it is aware of and a consistency proof from the first STH to the returned STH. The case where it knows the second but not the first should not arise (see the "no gaps" requirement above).
      </t>
      <t>
        If the log is unable to process a client's request, it MUST return an HTTP response code of 4xx/5xx (see <xref target="RFC2616"/>), and, in place of the responses outlined in the subsections below, the body SHOULD be a JSON structure containing at least the following field:
        <list style="hanging">
          <t hangText="error_message:">
                A human-readable string describing the error which prevented the log from processing the request.
          </t>
          <t>
                In the case of a malformed request, the string SHOULD provide sufficient detail for the error to be rectified.
          </t>
          <t hangText="error_code:">
            An error code readable by the client. Some codes are generic and are detailed here. Others are detailed in the individual requests. Error codes are fixed text strings.
            <list style="hanging">
              <t hangText="not compliant">
                The request is not compliant with this RFC.
              </t>
            </list>
          </t>
        </list>
      </t>
      <figure>
        <preamble>
          e.g. In response to a request of <spanx style="verb">/ct/v2/get-entries?start=100&amp;end=99</spanx>, the log would return a <spanx style="verb">400 Bad Request</spanx> response code with a body similar to the following:
        </preamble>
        <artwork>
    {
        "error_message": "'start' cannot be greater than 'end'",
        "error_code": "not compliant",
    }</artwork>
      </figure>
      <t>
        Clients SHOULD treat <spanx style="verb">500 Internal Server Error</spanx> and <spanx style="verb">503 Service Unavailable</spanx> responses as transient failures and MAY retry the same request without modification at a later date.  Note that as per <xref target="RFC2616"/>, in the case of a 503 response the log MAY include a <spanx style="verb">Retry-After:</spanx> header in order to request a minimum time for the client to wait before retrying the request.
      </t>
      <section title="Add Chain to Log" anchor="add-chain">
        <t>
          POST https://&lt;log server&gt;/ct/v2/add-chain
        </t>
        <t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="chain:">
                  An array of base64 encoded certificates. The first element is the certificate for which the submitter desires an SCT; the second certifies the first and so on to the last, which either is, or is certified by, an accepted trust anchor.
                </t>
              </list>
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="sct:">
                  A base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">x509_sct_v2</spanx>, signed by this log, that corresponds to the submitted certificate.
                </t>
              </list>
            </t>
            <t hangText="Error codes:">
              <list style="hanging">
                <t hangText="unknown anchor">
                  The last certificate in the chain both is not, and is not certified by, an accepted trust anchor.
                </t>
                <t hangText="bad chain">
                  The alleged chain is not actually a chain of certificates.
                </t>
                <t hangText="bad certificate">
                  One or more certificates in the chain are not valid (e.g. not properly encoded).
                </t>
                <t hangText="shutdown">
                  The log has ceased operation and is not accepting new submissions.
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>
          If the version of <spanx style="verb">sct</spanx> is not v2, then a v2 client may be unable to verify the signature. It MUST NOT construe this as an error. This is to avoid forcing an upgrade of compliant v2 clients that do not use the returned SCTs.
        </t>
        <t>
          If a log detects bad encoding in a chain that otherwise verifies correctly then the log MUST either log the certificate or return the "bad certificate" error. If the certificate is logged, an SCT MUST be issued. Logging the certificate is useful, because <xref target="monitor">monitors</xref> can then detect these encoding errors, which may be accepted by some TLS clients.
        </t>
      </section>

      <section title="Add PreCertChain to Log" anchor="add-pre-chain">
        <t>
          POST https://&lt;log server&gt;/ct/v2/add-pre-chain
        </t>
        <t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="precertificate:">
                  The base64 encoded precertificate.
                </t>
                <t hangText="chain:">
                  An array of base64 encoded CA certificates. The first element is the signer of the precertificate; the second certifies the first and so on to the last, which either is, or is certified by, an accepted trust anchor.
                </t>
              </list>
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="sct:">
                  A base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">precert_sct_v2</spanx>, signed by this log, that corresponds to the submitted precertificate.
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>
          Errors are the same as in <xref target="add-chain"/>.
        </t>
      </section>

      <section title="Retrieve Latest Signed Tree Head" anchor="get-sth">
        <t>
          GET https://&lt;log server&gt;/ct/v2/get-sth
        </t>
        <t>
          No inputs.
        </t>
        <t>
          <list style="hanging">
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="sth:">
                  A base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">signed_tree_head_v2</spanx>, signed by this log, that is no older than the log's MMD.
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>

      <section title="Retrieve Merkle Consistency Proof between Two Signed Tree Heads" anchor="get-sth-consistency">
        <t>
          GET https://&lt;log server&gt;/ct/v2/get-sth-consistency
        </t>
        <t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="first:">
                  The tree_size of the older tree, in decimal.
                </t>
                <t hangText="second:">
                  The tree_size of the newer tree, in decimal (optional).
                </t>
              </list>
            </t>
            <t>
              Both tree sizes must be from existing v2 STHs. However, because of skew, the receiving front-end may not know one or both of the existing STHs. If both are known, then only the <spanx style="verb">consistency</spanx> output is returned. If the first is known but the second is not (or has been omitted), then the latest known STH is returned, along with a consistency proof between the first STH and the latest. If neither are known, then the latest known STH is returned without a consistency proof.
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="consistency:">
                  A base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">consistency_proof_v2</spanx>, whose <spanx style="verb">tree_size_1</spanx> MUST match the <spanx style="verb">first</spanx> input. If the <spanx style="verb">sth</spanx> output is omitted, then <spanx style="verb">tree_size_2</spanx> MUST match the <spanx style="verb">second</spanx> input.
                </t>
                <t hangText="sth:">
                  A base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">signed_tree_head_v2</spanx>, signed by this log.
                </t>
              </list>
            </t>
            <t>
              Note that no signature is required for the <spanx style="verb">consistency</spanx> output as it is used to verify the consistency between two STHs, which are signed.
            </t>
            <t hangText="Error codes:">
              <list style="hanging">
                <t hangText="first unknown">
                  <spanx style="verb">first</spanx> is before the latest known STH but is not from an existing STH.
                </t>
                <t hangText="second unknown">
                  <spanx style="verb">second</spanx> is before the latest known STH but is not from an existing STH.
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>
          See <xref target="verify_consistency"/> for an outline of how to use the <spanx style="verb">consistency</spanx> output.
        </t>
      </section>

      <section title="Retrieve Merkle Inclusion Proof from Log by Leaf Hash" anchor="get-proof-by-hash">
        <t>
          GET https://&lt;log server&gt;/ct/v2/get-proof-by-hash
        </t>
        <t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="hash:">
                  A base64 encoded v2 leaf hash.
                </t>
                <t hangText="tree_size:">
                  The tree_size of the tree on which to base the proof, in decimal.
                </t>
              </list>
            </t>
            <t>
              The <spanx style="verb">hash</spanx> must be calculated as defined in <xref target="tree_leaves"/>. The <spanx style="verb">tree_size</spanx> must designate an existing v2 STH. Because of skew, the front-end may not know the requested STH. In that case, it will return the latest STH it knows, along with an inclusion proof to that STH. If the front-end knows the requested STH then only <spanx style="verb">inclusion</spanx> is returned.
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="inclusion:">
                  A base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">inclusion_proof_v2</spanx> whose <spanx style="verb">inclusion_path</spanx> array of Merkle Tree nodes proves the inclusion of the chosen certificate in the selected STH.
                </t>
                <t hangText="sth:">
                  A base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">signed_tree_head_v2</spanx>, signed by this log.
                </t>
              </list>
            </t>
            <t>
              Note that no signature is required for the <spanx style="verb">inclusion</spanx> output as it is used to verify inclusion in the selected STH, which is signed.
            </t>
            <t hangText="Error codes:">
              <list style="hanging">
                <t hangText="hash unknown">
                  <spanx style="verb">hash</spanx> is not the hash of a known leaf (may be caused by skew or by a known certificate not yet merged).
                </t>
                <t hangText="tree_size unknown">
                  <spanx style="verb">hash</spanx> is before the latest known STH but is not from an existing STH.
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>See <xref target="verify_inclusion"/> for an outline of how to use the <spanx style="verb">inclusion</spanx> output.</t>
      </section>

      <section title="Retrieve Merkle Inclusion Proof, Signed Tree Head and Consistency Proof by Leaf Hash" anchor="get-all-by-hash">
        <t>
          GET https://&lt;log server&gt;/ct/v2/get-all-by-hash
        </t>
        <t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="hash:">
                  A base64 encoded v2 leaf hash.
                </t>
                <t hangText="tree_size:">
                  The tree_size of the tree on which to base the proofs, in decimal.
                </t>
              </list>
            </t>
            <t>
              The <spanx style="verb">hash</spanx> must be calculated as defined in <xref target="tree_leaves"/>. The <spanx style="verb">tree_size</spanx> must designate an existing v2 STH.
            </t>
            <t>
              Because of skew, the front-end may not know the requested STH or the requested hash, which leads to a number of cases.
            </t>
            <t>
              <list style="hanging">
                <t hangText="latest STH &lt; requested STH">
                  Return latest STH.
                </t>
                <t hangText="latest STH &gt; requested STH">
                  Return latest STH and a consistency proof between it and the requested STH (see <xref target="get-sth-consistency"/>).
                </t>
                <t hangText="index of requested hash &lt; latest STH">
                  Return <spanx style="verb">inclusion</spanx>.
                </t>
              </list>
            </t>
            <t>
              Note that more than one case can be true, in which case the returned data is their concatenation. It is also possible for none to be true, in which case the front-end MUST return an empty response.
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="inclusion:">
                  A base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">inclusion_proof_v2</spanx> whose <spanx style="verb">inclusion_path</spanx> array of Merkle Tree nodes proves the inclusion of the chosen certificate in the returned STH.
                </t>
                <t hangText="sth:">
                  A base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">signed_tree_head_v2</spanx>, signed by this log.
                </t>
                <t hangText="consistency:">
                  A base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">consistency_proof_v2</spanx> that proves the consistency of the requested STH and the returned STH.
                </t>
              </list>
            </t>
            <t>
              Note that no signature is required for the <spanx style="verb">inclusion</spanx> or <spanx style="verb">consistency</spanx> outputs as they are used to verify inclusion in and consistency of STHs, which are signed.
            </t>
          </list>
        </t>
        <t>
          Errors are the same as in <xref target="get-proof-by-hash"/>.
        </t>
        <t>
          See <xref target="verify_inclusion"/> for an outline of how to use the <spanx style="verb">inclusion</spanx> output, and see <xref target="verify_consistency"/> for an outline of how to use the <spanx style="verb">consistency</spanx> output.
        </t>
      </section>

      <section title="Retrieve Entries and STH from Log" anchor="get-entries">
        <t>
          GET https://&lt;log server&gt;/ct/v2/get-entries
        </t>
        <t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="start:">
                  0-based index of first entry to retrieve, in decimal.
                </t>
                <t hangText="end:">
                  0-based index of last entry to retrieve, in decimal.
                </t>
              </list>
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="entries:">
                  An array of objects, each consisting of
                  <list style="hanging">
                    <t hangText="leaf_input:">
                      The base64 encoded <spanx style="verb">TransItem</spanx> structure of type <spanx style="verb">x509_entry_v2</spanx> or <spanx style="verb">precert_entry_v2</spanx> (see <xref target="tree_leaves"/>).
                    </t>
                    <t hangText="log_entry:">
                      The base64 encoded log entry (see <xref target="log_entries"/>). In the case of an <spanx style="verb">x509_entry_v2</spanx> entry, this is the whole <spanx style="verb">X509ChainEntry</spanx>; and in the case of a <spanx style="verb">precert_entry_v2</spanx>, this is the whole <spanx style="verb">PrecertChainEntryV2</spanx>.
                    </t>
                    <t hangText="sct:">
                      The base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">x509_sct_v2</spanx> or <spanx style="verb">precert_sct_v2</spanx> corresponding to this log entry.
                    </t>
                  </list>
                </t>
                <t hangText="sth:">
                  A base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">signed_tree_head_v2</spanx>, signed by this log.
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>
          Note that this message is not signed -- the <spanx style="verb">entries</spanx> data can be verified by constructing the Merkle Tree Hash corresponding to a retrieved STH. All leaves MUST be v2. However, a compliant v2 client MUST NOT construe an unrecognized TransItem type as an error. This means it may be unable to parse some entries, but note that each client can inspect the entries it does recognize as well as verify the integrity of the data by treating unrecognized leaves as opaque input to the tree.
        </t>
        <t>
          The <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> parameters SHOULD be within the range 0 &lt;= x &lt; <spanx style="verb">tree_size</spanx> as returned by <spanx style="verb">get-sth</spanx> in <xref target="get-sth"/>.
        </t>
        <t>
          The <spanx style="verb">start</spanx> parameter MUST be less than or equal to the <spanx style="verb">end</spanx> parameter.
        </t>
        <t>
          Log servers MUST honor requests where 0 &lt;= <spanx style="verb">start</spanx> &lt; <spanx style="verb">tree_size</spanx> and <spanx style="verb">end</spanx> &gt;= <spanx style="verb">tree_size</spanx> by returning a partial response covering only the valid entries in the specified range. <spanx style="verb">end</spanx> &gt;= <spanx style="verb">tree_size</spanx> could be caused by skew. Note that the following restriction may also apply:
        </t>
        <t>
          Logs MAY restrict the number of entries that can be retrieved per
<spanx style="verb">get-entries</spanx> request.  If a client requests more
than the permitted number of entries, the log SHALL return the maximum number
of entries permissible. These entries SHALL be sequential beginning with the
entry specified by <spanx style="verb">start</spanx>.
        </t>
        <t>
          Because of skew, it is possible the log server will not have any entries between <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx>. In this case it MUST return an empty <spanx style="verb">entries</spanx> array.
        </t>
        <t>
          In any case, the log server MUST return the latest STH it knows about.
        </t>
        <t>See <xref target="verify_hash" /> for an outline of how to use a complete list of <spanx style="verb">leaf_input</spanx> entries to verify the <spanx style="verb">root_hash</spanx>.</t>
      </section>

      <section title="Retrieve Accepted Trust Anchors" anchor="get-anchors">
        <t>
          GET https://&lt;log server&gt;/ct/v2/get-anchors
        </t>
        <t>
          No inputs.
        </t>
        <t>
          <list style="hanging">
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="certificates:">
                  An array of base64 encoded trust anchors that are acceptable to the log.
                </t>
                <t hangText="max_chain:">
                  If the server has chosen to limit the length of chains it accepts, this is the maximum number of certificates in the chain, in decimal. If there is no limit, this is omitted.
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
    </section>
    <section title="Optional Client Messages">
	<t>
	  Logs MAY implement these messages. They are not required for correct operation of logs or their clients, but may be convenient in some circumstances. Note that mirrors can implement these even if the log they are mirroring does not.
	</t>
      <section title="Get Entry Number for SCT">
	<t>
	  GET https://&lt;log server&gt;/ct/v2/get-entry-for-sct
	</t>
	<t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="sct:">
                  A base64 encoded <spanx style="verb">TransItem</spanx> of type <spanx style="verb">x509_sct_v2</spanx> or <spanx style="verb">precert_sct_v2</spanx> signed by this log.
                </t>
              </list>
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="entry:">
		  0-based index of the log entry corresponding to the supplied SCT.
                </t>
              </list>
            </t>
            <t hangText="Error codes:">
              <list style="hanging">
                <t hangText="bad signature">
                  <spanx style="verb">sct</spanx> is not signed by this log.
		</t>
                <t hangText="not found">
                  <spanx style="verb">sct</spanx> does not correspond to an entry that is currently available.
		</t>
	      </list>
	    </t>
          </list>
        </t>
	<t>
	  Note that any SCT signed by a log MUST have a corresponding entry in the log, but it may not be retrievable until the MMD has passed since the SCT was issued.
	</t>
      </section>

      <section title="Get Entry Numbers for Certificate">
	<t>
	  GET https://&lt;log server&gt;/ct/v2/get-entry-for-certificate
	</t>
	<t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="hash:">
                  A base64 encoded HASH of a <spanx style="verb">TBSCertificate</spanx>. Note that if the certificate has redacted labels then the <spanx style="verb">TBSCertificate</spanx> must be constructed as described <xref target="domain_name_redaction">above</xref>.
                </t>
              </list>
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="entries:">
		  An array of 0-based indices of log entries corresponding to the supplied HASH.
                </t>
              </list>
            </t>
            <t hangText="Error codes:">
              <list style="hanging">
                <t hangText="bad hash">
                  <spanx style="verb">hash</spanx> is not the right size or format.
		</t>
                <t hangText="not found">
                  <spanx style="verb">sct</spanx> does not correspond to an entry that is currently available.
		</t>
	      </list>
	    </t>
          </list>
        </t>
	<t>
	  Note that it is possible for a certificate to be logged more than once. If that is the case, the log MAY return more than one entry index. If the certificate is present in the log, then the log MUST return at least one entry index.
	</t>
      </section>
    </section>
    <section title="TLS Servers" anchor="tls_servers">
      <t>
        TLS servers MUST use at least one of the three mechanisms listed below to present one or more SCTs from one or more logs to each TLS client during full TLS handshakes, where each SCT corresponds to the server certificate or to a name-constrained intermediate the server certificate chains to. TLS servers SHOULD also present corresponding inclusion proofs and STHs (see <xref target="sct_with_proof"/>).
      </t>
      <t>
        Three mechanisms are provided because they have different tradeoffs.
        <list style="symbols">
          <t>
            A TLS extension (Section 7.4.1.4 of <xref target='RFC5246'/>) with type <spanx style="verb">transparency_info</spanx> (see <xref target="tls_transinfo_extension"/>). This mechanism allows TLS servers to participate in CT without the cooperation of CAs, unlike the other two mechanisms. It also allows SCTs and inclusion proofs to be updated on the fly.
          </t>
          <t>
            An <xref target='RFC6960'>Online Certificate Status Protocol (OCSP)</xref> response extension (see <xref target="ocsp_transinfo_extension"/>), where the OCSP response is provided in the <spanx style="verb">CertificateStatus</spanx> message, provided that the TLS client included the <spanx style="verb">status_request</spanx> extension in the (extended) <spanx style="verb">ClientHello</spanx> (Section 8 of <xref target='RFC6066'/>). This mechanism, popularly known as OCSP stapling, is already widely (but not universally) implemented. It also allows SCTs and inclusion proofs to be updated on the fly.
          </t>
          <t>
            An X509v3 certificate extension (see <xref target="cert_transinfo_extension"/>). This mechanism allows the use of unmodified TLS servers, but the SCTs and inclusion proofs cannot be updated on the fly. Since the logs from where the SCTs and inclusion proofs originated won't necessarily be accepted by TLS clients for the full lifetime of the certificate, there is a risk that TLS clients will subsequently consider the certificate to be non-compliant and in need of re-issuance.
          </t>
        </list>
      </t>
      <t>
        Additionally, a TLS server which supports presenting SCTs using an OCSP response MAY provide it when the TLS client included the <spanx style="verb">status_request_v2</spanx> extension (<xref target='RFC6961'/>) in the (extended) <spanx style="verb">ClientHello</spanx>, but only in addition to at least one of the three mechanisms listed above.
      </t>
      <section title="Multiple SCTs" anchor="multiple-scts">
        <t>
          TLS servers SHOULD send SCTs from multiple logs in case one or more logs are not acceptable to the TLS client (for example, if a log has been struck off for misbehavior, has had a key compromise, or is not known to the TLS client). For example:
          <list style="symbols">
            <t>
              If a CA and a log collude, it is possible to temporarily hide misissuance from clients. Including SCTs from different logs makes it more difficult to mount this attack.
            </t>
            <t>
              If a log misbehaves, a consequence may be that clients cease to trust it. Since the time an SCT may be in use can be considerable (several years is common in current practice when embedded in a certificate), servers may wish to reduce the probability of their certificates being rejected as a result by including SCTs from different logs.
            </t>
            <t>
              TLS clients may have policies related to the above risks requiring servers to present multiple SCTs. For example, at the time of writing, <xref target="Chromium.Log.Policy">Chromium</xref> requires multiple SCTs to be presented with EV certificates in order for the EV indicator to be shown.
            </t>
          </list>
          To select the logs from which to obtain SCTs, a TLS server can, for example, examine the set of logs popular TLS clients accept and recognize.
        </t>
      </section>
      <section title="TransItemList Structure">
        <figure>
          <preamble>
            Multiple SCTs, inclusion proofs, and indeed <spanx style="verb">TransItem</spanx> structures of any type, are combined into a list as follows:
          </preamble>
          <artwork>
      opaque SerializedTransItem&lt;1..2^16-1&gt;;

      struct {
          SerializedTransItem trans_item_list&lt;1..2^16-1&gt;;
      } TransItemList;</artwork>
        </figure>
        <t>
          Here, <spanx style="verb">SerializedTransItem</spanx> is an opaque byte string that contains the serialized <spanx style="verb">TransItem</spanx> structure. This encoding ensures that TLS clients can decode each <spanx style="verb">TransItem</spanx> individually (so, for example, if there is a version upgrade, out-of-date clients can still parse old <spanx style="verb">TransItem</spanx> structures while skipping over new <spanx style="verb">TransItem</spanx> structures whose versions they don't understand).
        </t>
      </section>
      <section title="Presenting SCTs, inclusion proofs and STHs" anchor="sct_with_proof">
        <figure>
          <preamble>
            When constructing a <spanx style="verb">TransItemList</spanx> structure, a TLS server SHOULD construct and include <spanx style="verb">TransItem</spanx> structures of type <spanx style="verb">x509_sct_with_proof_v2</spanx> (for an SCT of type <spanx style="verb">x509_sct_v2</spanx>) or <spanx style="verb">precert_sct_with_proof_v2</spanx> (for an SCT of type <spanx style="verb">precert_sct_v2</spanx>), both of which encapsulate a <spanx style="verb">SCTWithProofDataV2</spanx> structure:
          </preamble>
          <artwork>
    struct {
        SignedCertificateTimestampDataV2 sct;
        SignedTreeHeadDataV2 sth;
        InclusionProofDataV2 inclusion_proof;
    } SCTWithProofDataV2;</artwork>
        </figure>
        <t>
          <spanx style="verb">sct</spanx> is the encapsulated data structure from an SCT that corresponds to the server certificate or to a name-constrained intermediate the server certificate chains to.
        </t>
        <t>
          <spanx style="verb">sth</spanx> is the encapsulated data structure from an STH that was signed by the same log as <spanx style="verb">sct</spanx>.
        </t>
        <t>
          <spanx style="verb">inclusion_proof</spanx> is the encapsulated data structure from an inclusion proof that corresponds to <spanx style="verb">sct</spanx> and can be used to compute the root in <spanx style="verb">sth</spanx>.
        </t>
      </section>
      <section title="Presenting SCTs only">
        <t>
          Presenting inclusion proofs and STHs in the TLS handshake helps to protect the client's privacy (see <xref target="validating_inclusion_proofs"/>) and reduces load on log servers. However, if a TLS server is unable to obtain an inclusion proof and STH that correspond to an SCT, then it MUST include <spanx style="verb">TransItem</spanx> structures of type <spanx style="verb">x509_sct_v2</spanx> or <spanx style="verb">precert_sct_v2</spanx> in the <spanx style="verb">TransItemList</spanx>.
        </t>
      </section>
      <section title="transparency_info TLS Extension" anchor="tls_transinfo_extension">
        <t>
          Provided that a TLS client includes the <spanx style="verb">transparency_info</spanx> extension type in the ClientHello, the TLS server SHOULD include the <spanx style="verb">transparency_info</spanx> extension in the ServerHello with <spanx style="verb">extension_data</spanx> set to a <spanx style="verb">TransItemList</spanx>. The TLS server SHOULD ignore any <spanx style="verb">extension_data</spanx> sent by the TLS client. Additionally, the TLS server MUST NOT process or include this extension when a TLS session is resumed, since session resumption uses the original session information.
        </t>
      </section>
    </section>
    <section title="Certification Authorities">
      <section title="Transparency Information X.509v3 Extension" anchor="x509v3_transinfo_extension">
        <figure>
          <preamble>
            The Transparency Information X.509v3 extension, which has OID 1.3.101.75 and SHOULD be non-critical, contains one or more <spanx style="verb">TransItem</spanx> structures in a <spanx style="verb">TransItemList</spanx>. This extension MAY be included in OCSP responses (see <xref target="ocsp_transinfo_extension"/>) and certificates (see <xref target="cert_transinfo_extension"/>). Since RFC5280 requires the <spanx style="verb">extnValue</spanx> field (an OCTET STRING) of each X.509v3 extension to include the DER encoding of an ASN.1 value, a <spanx style="verb">TransItemList</spanx> MUST NOT be included directly. Instead, it MUST be wrapped inside an additional OCTET STRING, which is then put into the <spanx style="verb">extnValue</spanx> field:
          </preamble>
          <artwork>
    TransparencyInformationSyntax ::= OCTET STRING</artwork>
        </figure>
        <t>
          <spanx style="verb">TransparencyInformationSyntax</spanx> contains a <spanx style="verb">TransItemList</spanx>.
        </t>
        <section title="OCSP Response Extension" anchor="ocsp_transinfo_extension">
          <t>
            A certification authority MAY include a Transparency Information X.509v3 extension in the <spanx style="verb">singleExtensions</spanx> of a <spanx style="verb">SingleResponse</spanx> in an OCSP response. The included SCTs or inclusion proofs MUST be for the certificate identified by the <spanx style="verb">certID</spanx> of that <spanx style="verb">SingleResponse</spanx>, or for a precertificate that corresponds to that certificate, or for a name-constrained intermediate to which that certificate chains.
          </t>
        </section>
        <section title="Certificate Extension" anchor="cert_transinfo_extension">
          <t>
            A certification authority MAY include a Transparency Information X.509v3 extension in a certificate. Any included SCTs or inclusion proofs MUST be either for a precertificate that corresponds to this certificate, or for a name-constrained intermediate to which this certificate chains.
          </t>
        </section>
      </section>
      <section title="TLS Feature Extension" anchor="tls_feature_extension">
        <t>
          A certification authority MAY include the <xref target="tls_transinfo_extension">transparency_info</xref> TLS extension identifier in the <xref target="RFC7633">TLS Feature</xref> certificate extension in root, intermediate and end-entity certificates. When a certificate chain includes such a certificate, this indicates that CT compliance is required.
        </t>
      </section>
    </section>
    <section title="Clients">
      <t>
        There are various different functions clients of logs might perform. We
describe here some typical clients and how they should function. Any
inconsistency may be used as evidence that a log has not behaved correctly, and
the signatures on the data structures prevent the log from denying that
misbehavior.
      </t>
      <t>
        All clients need various metadata in order to communicate with logs and verify their responses. This metadata is described below, but note that this document does not describe how the metadata is obtained, which is implementation dependent (see, for example, <xref target="Chromium.Policy"/>).
      </t>
      <t>
        Clients should somehow exchange STHs they see, or make them
available for scrutiny, in order to ensure that they all have a
consistent view. The exact mechanisms will be in separate documents,
but it is expected there will be a variety.
      </t>
      <section title="Metadata" anchor="metadata">
        <t>
          In order to communicate with and verify a log, clients need metadata about the log.
        </t>
        <t><list style="hanging">
          <t hangText="Base URL:">
            The URL to substitute for &lt;log server&gt; in <xref target="client_messages"/>.
          </t>
          <t hangText="Hash Algorithm">
            The hash algorithm used for the Merkle Tree (see <xref target="hash_algorithms"/>).
          </t>
          <t hangText="Signing Algorithm">
            The signing algorithm used (see <xref target="signatures"/>).
          </t>
          <t hangText="Public Key">
            The public key used to verify signatures generated by the log. A log MUST NOT use the same keypair as any other log.
          </t>
          <t hangText="Log ID">
            The OID that uniquely identifies the log.
          </t>
          <t hangText="Maximum Merge Delay">
            The MMD the log has committed to.
          </t>
          <t hangText="Version">
            The version of the protocol supported by the log (currently 1 or 2).
          </t>
          <t hangText="Maximum Chain Length">
            The longest chain submission the log is willing to accept, if the log chose to limit it.
          </t>
          <t hangText="STH Frequency Count">
            The maximum number of STHs the log may produce in any period equal to the <spanx style="verb">Maximum Merge Delay</spanx> (see <xref target="STH"/>).
          </t>
          <t hangText="Final STH">
            If a log has been closed down (i.e. no longer accepts new entries), existing entries may still be valid. In this case, the client should know the final valid STH in the log to ensure no new entries can be added without detection. The final STH should be provided in the form of a TransItem of type signed_tree_head_v2.
          </t>
        </list></t>
        <t>
          <xref target="JSON.Metadata"/> is an example of a metadata format which includes the above elements.
        </t>
      </section>
      <section title="TLS Client" anchor="tls_clients">
        <section title="Receiving SCTs">
          <t>
            TLS clients receive SCTs alongside or in certificates. TLS clients MUST implement all of the three mechanisms by which TLS servers may present SCTs (see <xref target="tls_servers"/>). TLS clients MAY also accept SCTs via the <spanx style="verb">status_request_v2</spanx> extension (<xref target='RFC6961'/>). TLS clients that support the <spanx style="verb">transparency_info</spanx> TLS extension SHOULD include it in ClientHello messages, with empty <spanx style="verb">extension_data</spanx>. TLS clients may also receive inclusion proofs in addition to SCTs, which should be checked once the SCTs are validated.
          </t>
        </section>
        <section title="Reconstructing the TBSCertificate" anchor="reconstructing_tbscertificate">
          <t>
            To reconstruct the TBSCertificate component of a precertificate from a certificate, TLS clients should:
            <list style="symbols">
              <t>
                Remove the Transparency Information extension described in <xref target="x509v3_transinfo_extension"/>.
              </t>
              <t>
                If the redactedSubjectAltName extension (<xref target="redacted_san_extension"/>) is present:
                <list style="symbols">
                  <t>TLS clients MUST verify it against the subjectAltName extension according to <xref target="verifying_redacted_san"/>.</t>
                  <t>Once verified, remove the subjectAltName extension from the TBSCertificate.</t>
                </list>
              </t>
            </list>
          </t>
          <t>
            If the SCT checked is for a Precertificate (where the <spanx style="verb">type</spanx> of the <spanx style="verb">TransItem</spanx> is <spanx style="verb">precert_sct_v2</spanx>), then the client SHOULD also remove embedded v1 SCTs, identified by OID 1.3.6.1.4.1.11129.2.4.2 (See Section 3.3. of <xref target="RFC6962"/>), in the process of reconstructing the TBSCertificate. That is to allow embedded v1 and v2 SCTs to co-exist in a certificate (See <xref target="v1_coexistence"/>).
          </t>
        </section>
        <section title="Verifying the redactedSubjectAltName extension" anchor="verifying_redacted_san">
          <t>
            If the redactedSubjectAltName extension is present, TLS clients MUST check that the subjectAltName extension is present, that the subjectAltName extension contains the same number of entries as the redactedSubjectAltName extension, and that each entry in the subjectAltName extension has a matching entry at the same position in the redactedSubjectAltName extension. Two entries are matching if either:
            <list style="symbols">
              <t>The two entries are identical; or,</t>
              <t>Both entries are DNS-IDs, have the same number of labels, and each label in the subjectAltName entry has a matching label at the same position in the redactedSubjectAltName entry. Two labels are matching if either:
                <list style="symbols">
                  <t>The two labels are identical; or,</t>
                  <t>Neither label is <spanx style="verb">*</spanx> and the label from the redactedSubjectAltName entry is equal to REDACT(label from subjectAltName entry) (<xref target="redacting_labels"/>).</t>
                </list>
              </t>
            </list>
          </t>
          <t>
            If any of these checks fail, the certificate MUST NOT be considered compliant.
          </t>
        </section>
        <section title="Validating SCTs">
          <t>
            In addition to normal validation of the server certificate and its chain, TLS clients SHOULD validate each received SCT for which they have the corresponding log's metadata. To validate an SCT, a TLS client computes the signature input from the SCT data and the corresponding certificate, and then verifies the signature using the corresponding log's public key. TLS clients MUST NOT consider valid any SCT whose timestamp is in the future.
          </t>
          <t>
            Before considering any SCT to be invalid, the TLS client MUST attempt to validate it against the server certificate and against each of the zero or more <xref target="name_constrained">suitable name-constrained intermediates</xref> in the chain. These certificates may be evaluated in the order they appear in the chain, or, indeed, in any order.
          </t>
        </section>
        <section title="Validating inclusion proofs" anchor="validating_inclusion_proofs">
          <t>
            After validating a received SCT, a TLS client MAY request a corresponding inclusion proof (if one is not already available) and then verify it. An inclusion proof can be requested directly from a log using <spanx style="verb">get-proof-by-hash</spanx> (<xref target="get-proof-by-hash"/>) or <spanx style="verb">get-all-by-hash</spanx> (<xref target="get-all-by-hash"/>), but note that this will disclose to the log which TLS server the client has been communicating with.
          </t>
          <t>
            Alternatively, if the TLS client has received an inclusion proof (and an STH) alongside the SCT, it can proceed to verifying the inclusion proof to the provided STH. The client then has to verify consistency between the provided STH and an STH it knows about, which is less sensitive from a privacy perspective.
          </t>
          <t>
            TLS clients SHOULD also verify each received inclusion proof (see <xref target="verify_inclusion"/>) for which they have the corresponding log's metadata, to audit the log and gain confidence that the certificate is logged.
          </t>
          <t>
            If the TLS client holds an STH that predates the SCT, it MAY, in the process of auditing, request a new STH from the log (<xref target="get-sth"/>), then verify it by requesting a consistency proof (<xref target="get-sth-consistency"/>). Note that if the TLS client uses <spanx style="verb">get-all-by-hash</spanx>, then it will already have the new STH.
          </t>
        </section>
        <section title="Evaluating compliance">
          <t>
            To be considered compliant, a certificate MUST be accompanied by at least one valid SCT. A certificate not accompanied by any valid SCTs MUST NOT be considered compliant by TLS clients.
          </t>
        </section>
        <section title="TLS Feature Extension">
          <t>
            If any certificate in a chain includes the <xref target="tls_transinfo_extension">transparency_info</xref> TLS extension identifier in the <xref target="RFC7633">TLS Feature</xref> certificate extension, then CT compliance (using any of the mechanisms from <xref target="tls_servers"/>) is required.
          </t>
        </section>
        <section title="Handling of Non-compliance">
          <t>
            If a TLS server presents a certificate chain that is non-compliant, and the use of a compliant certificate is mandated by an explicit security policy, application protocol specification, the TLS Feature extension or any other means, the TLS client MUST refuse the connection.
          </t>
        </section>
      </section>
      <section title="Monitor" anchor="monitor">
        <t>
          Monitors watch logs to check that they behave correctly, for certificates of interest, or both. For example, a monitor may be configured to report on all certificates that apply to a specific domain name when fetching new entries for consistency validation.
        </t>
        <t>
          A monitor needs to, at least, inspect every new entry in each log it watches. It may also want to keep copies of entire logs. In order to do this, it should follow these steps for each log:
          <list style="numbers">
            <t>
              Fetch the current STH (<xref target="get-sth"/>).
            </t>
            <t>
              Verify the STH signature.
            </t>
            <t>
              Fetch all the entries in the tree corresponding to the STH (<xref target="get-entries"/>).
            </t>
            <t>
              Confirm that the tree made from the fetched entries produces the same hash as that in the STH.
            </t>
            <t anchor="monitor_loop">
              Fetch the current STH (<xref target="get-sth"/>). Repeat until the STH changes.
            </t>
            <t>
              Verify the STH signature.
            </t>
            <t>
              Fetch all the new entries in the tree corresponding to the STH
(<xref target="get-entries"/>). If they remain unavailable for an extended period, then this should be viewed as misbehavior on the part of the log.
            </t>
            <t>
              Either:
              <list style="numbers">
                <t>
                  Verify that the updated list of all entries generates a tree with the same hash as the new STH.
                </t>
              </list>
              Or, if it is not keeping all log entries:
              <list style="numbers">
                <t>
                  Fetch a consistency proof for the new STH with the previous STH (<xref target="get-sth-consistency"/>).
                </t>
                <t>
                  Verify the consistency proof.
                </t>
                <t>
                  Verify that the new entries generate the corresponding elements in the consistency proof.
                </t>
              </list>
            </t>
            <t>
              Go to Step 5.
            </t>
          </list>
        </t>
      </section>
      <section title="Auditing">
        <t>
          Auditing ensures that the current published state of a log is reachable from previously published states that are known to be good, and that the promises made by the log in the form of SCTs have been kept.  Audits are performed by monitors or TLS clients.
        </t>
        <t>
          In particular, there are four log behaviour properties that should be checked:
          <list style="symbols">
            <t>
              The Maximum Merge Delay (MMD).
            </t>
            <t>
              The STH Frequency Count.
            </t>
            <t>
              The append-only property.
            </t>
            <t>
              The consistency of the log view presented to all query sources.
            </t>
          </list>
        </t>
        <t>
          A benign, conformant log publishes a series of STHs over time, each derived from the previous STH and the submitted entries incorporated into the log since publication of the previous STH.  This can be proven through auditing of STHs.  SCTs returned to TLS clients can be audited by verifying against the accompanying certificate, and using Merkle Inclusion Proofs, against the log's Merkle tree.
        </t>
        <t>
          The action taken by the auditor if an audit fails is not specified, but note that in general if audit fails, the auditor is in possession of signed proof of the log's misbehavior.
        </t>
        <t>
          A <xref target="monitor">monitor</xref> can audit by verifying the consistency of STHs it receives, ensure that each entry can be fetched and that the STH is indeed the result of making a tree from all fetched entries.
        </t>
        <t>
          A <xref target="tls_clients">TLS client</xref> can audit by verifying an SCT against any STH dated after the SCT timestamp + the Maximum Merge Delay by requesting a Merkle inclusion proof (<xref target="get-proof-by-hash"/>). It can also verify that the SCT corresponds to the certificate it arrived with (i.e. the log entry is that certificate, is a precertificate for that certificate or is an appropriate name-constrained intermediate [see <xref target="name_constrained"/>]).
        </t>
        <t>
          Checking of the consistency of the log view presented to all entities is more difficult to perform because it requires a way to share log responses among a set of CT-aware entities, and is discussed in <xref target="misbehaving_logs"/>.
        </t>
        <t>
          The following algorithm outlines may be useful for clients that wish to perform various audit operations.
        </t>
        <section title="Verifying an inclusion proof" anchor="verify_inclusion">
          <t>
            When a client has received a <spanx style="verb">TransItem</spanx> of type <spanx style="verb">inclusion_proof_v2</spanx> and wishes to verify inclusion of an input <spanx style="verb">hash</spanx> for an STH with a given <spanx style="verb">tree_size</spanx> and <spanx style="verb">root_hash</spanx>, the following algorithm may be used to prove the <spanx style="verb">hash</spanx> was included in the <spanx style="verb">root_hash</spanx>:
            <list style="numbers">
              <t>Compare <spanx style="verb">leaf_index</spanx> against <spanx style="verb">tree_size</spanx>. If <spanx style="verb">leaf_index</spanx> is greater than or equal to <spanx style="verb">tree_size</spanx> fail the proof verification.</t>
              <t>Set <spanx style="verb">fn</spanx> to <spanx style="verb">leaf_index</spanx> and <spanx style="verb">sn</spanx> to <spanx style="verb">tree_size - 1</spanx>.</t>
              <t>Set <spanx style="verb">r</spanx> to <spanx style="verb">hash</spanx>.</t>
              <t>
                For each value <spanx style="verb">p</spanx> in the <spanx style="verb">inclusion_path</spanx> array:
                <vspace blankLines="1" />
                If <spanx style="verb">LSB(fn)</spanx> is set, or if <spanx style="verb">fn</spanx> is equal to <spanx style="verb">sn</spanx>, then:
                <list style="numbers">
                  <t>
                    Set <spanx style="verb">r</spanx> to <spanx style="verb">HASH(0x01 || p || r)</spanx>
                  </t>
                  <t>If <spanx style="verb">LSB(fn)</spanx> is not set, then right-shift both <spanx style="verb">fn</spanx> and <spanx style="verb">sn</spanx> equally until either <spanx style="verb">LSB(fn)</spanx> is set or <spanx style="verb">fn</spanx> is <spanx style="verb">0</spanx>.</t>
                </list>
                Otherwise:
                <list style="empty">
                  <t>Set <spanx style="verb">r</spanx> to <spanx style="verb">HASH(0x01 || r || p)</spanx></t>
                </list>
                <vspace blankLines="1" />
                Finally, right-shift both <spanx style="verb">fn</spanx> and <spanx style="verb">sn</spanx> one time.
              </t>
              <t>Compare <spanx style="verb">sn</spanx> to 0. Compare <spanx style="verb">r</spanx> against the <spanx style="verb">root_hash</spanx>. If <spanx style="verb">sn</spanx> is equal to 0, and  <spanx style="verb">r</spanx> and the <spanx style="verb">root_hash</spanx> are equal, then the log has proven the inclusion of <spanx style="verb">hash</spanx>. Otherwise, fail the proof verification.</t>
            </list>
          </t>
        </section>
        <section title="Verifying consistency between two STHs" anchor="verify_consistency">
          <t>
            When a client has an STH <spanx style="verb">first_hash</spanx> for tree size <spanx style="verb">first</spanx>, an STH <spanx style="verb">second_hash</spanx> for tree size <spanx style="verb">second</spanx> where <spanx style="verb">0 &lt; first &lt; second</spanx>, and has received a <spanx style="verb">TransItem</spanx> of type <spanx style="verb">consistency_proof_v2</spanx> that they wish to use to verify both hashes, the following algorithm may be used:
            <list style="numbers">
              <t>If <spanx style="verb">first</spanx> is an exact power of 2, then prepend <spanx style="verb">first_hash</spanx> to the <spanx style="verb">consistency_path</spanx> array.</t>
              <t>Set <spanx style="verb">fn</spanx> to <spanx style="verb">first - 1</spanx> and <spanx style="verb">sn</spanx> to <spanx style="verb">second - 1</spanx>.</t>
              <t>If <spanx style="verb">LSB(fn)</spanx> is set, then right-shift both <spanx style="verb">fn</spanx> and <spanx style="verb">sn</spanx> equally until <spanx style="verb">LSB(fn)</spanx> is not set.</t>
              <t>Set both <spanx style="verb">fr</spanx> and <spanx style="verb">sr</spanx> to the first value in the <spanx style="verb">consistency_path</spanx> array.</t>
              <t>
                For each subsequent value <spanx style="verb">c</spanx> in the <spanx style="verb">consistency_path</spanx> array:
                <vspace blankLines="1" />
                If <spanx style="verb">sn</spanx> is 0, stop the iteration and fail the proof verification.
                <vspace blankLines="1" />
                If <spanx style="verb">LSB(fn)</spanx> is set, or if <spanx style="verb">fn</spanx> is equal to <spanx style="verb">sn</spanx>, then:
                <list style="numbers">
                  <t>
                    Set <spanx style="verb">fr</spanx> to <spanx style="verb">HASH(0x01 || c || fr)</spanx>
                    <vspace blankLines="0" />
                    Set <spanx style="verb">sr</spanx> to <spanx style="verb">HASH(0x01 || c || sr)</spanx>
                  </t>
                  <t>If <spanx style="verb">LSB(fn)</spanx> is not set, then right-shift both <spanx style="verb">fn</spanx> and <spanx style="verb">sn</spanx> equally until either <spanx style="verb">LSB(fn)</spanx> is set or <spanx style="verb">fn</spanx> is <spanx style="verb">0</spanx>.</t>
                </list>
                Otherwise:
                <list style="empty">
                  <t>Set <spanx style="verb">sr</spanx> to <spanx style="verb">HASH(0x01 || sr || c)</spanx></t>
                </list>
                <vspace blankLines="1" />
                Finally, right-shift both <spanx style="verb">fn</spanx> and <spanx style="verb">sn</spanx> one time.
              </t>
              <t>After completing iterating through the <spanx style="verb">consistency_path</spanx> array as described above, verify that the <spanx style="verb">fr</spanx> calculated is equal to the <spanx style="verb">first_hash</spanx> supplied, that the <spanx style="verb">sr</spanx> calculated is equal to the <spanx style="verb">second_hash</spanx> supplied and that <spanx style="verb">sn</spanx> is 0.</t>
            </list>
          </t>
        </section>
        <section title="Verifying root hash given entries" anchor="verify_hash">
          <t>
            When a client has a complete list of leaf input <spanx style="verb">entries</spanx> from <spanx style="verb">0</spanx> up to <spanx style="verb">tree_size - 1</spanx> and wishes to verify this list against an STH <spanx style="verb">root_hash</spanx> returned by the log for the same <spanx style="verb">tree_size</spanx>, the following algorithm may be used:
            <list style="numbers">
              <t>Set <spanx style="verb">stack</spanx> to an empty stack.</t>
              <t>
                 For each <spanx style="verb">i</spanx> from <spanx style="verb">0</spanx> up to <spanx style="verb">tree_size - 1</spanx>:
                 <list style="numbers">
                   <t>Push <spanx style="verb">HASH(0x00 || entries[i])</spanx> to <spanx style="verb">stack</spanx>.</t>
                   <t>Set <spanx style="verb">merge_count</spanx> to the lowest value (<spanx style="verb">0</spanx> included) such that <spanx style="verb">LSB(i >> merge_count)</spanx> is not set.  In other words, set <spanx style="verb">merge_count</spanx> to the number of consecutive <spanx style="verb">1</spanx>s found starting at the least significant bit of <spanx style="verb">i</spanx>.</t>
                   <t>
                     Repeat <spanx style="verb">merge_count</spanx> times:
                     <list style="numbers">
                       <t>Pop <spanx style="verb">right</spanx> from <spanx style="verb">stack</spanx>.</t>
                       <t>Pop <spanx style="verb">left</spanx> from <spanx style="verb">stack</spanx>.</t>
                       <t>Push <spanx style="verb">HASH(0x01 || left || right)</spanx> to <spanx style="verb">stack</spanx>.</t>
                     </list>
                   </t>
                 </list>
               </t>
               <t>If there is more than one element in the <spanx style="verb">stack</spanx>, repeat the same merge procedure (Step 2.3 above) until only a single element remains.</t>
               <t>The remaining element in <spanx style="verb">stack</spanx> is the Merkle Tree hash for the given <spanx style="verb">tree_size</spanx> and should be compared by equality against the supplied <spanx style="verb">root_hash</spanx>.</t>
            </list>
          </t>
        </section>
      </section>
    </section>

    <section title="Algorithm Agility">
      <t>
        It is not possible for a log to change any of its algorithms part way through its lifetime:
        <list style="hanging">
          <t hangText="Signature algorithm:">SCT signatures must remain valid so signature algorithms can only be added, not removed.</t>
          <t hangText="Hash algorithm:">A log would have to support the old and new hash algorithms to allow backwards-compatibility with clients that are not aware of a hash algorithm change. </t>
        </list>
        Allowing multiple signature or hash algorithms for a log would require that all data structures support it and would significantly complicate client implementation, which is why it is not supported by this document.
      </t>
      <t>If it should become necessary to deprecate an algorithm used by a live log, then the log should be frozen as specified in <xref target="metadata"/> and a new log should be started. Certificates in the frozen log that have not yet expired and require new SCTs SHOULD be submitted to the new log and the SCTs from that log used instead.
      </t>
    </section>

    <section title="IANA Considerations">
      <section title="TLS Extension Type">
        <t>
          IANA is asked to allocate an RFC 5246 ExtensionType value for the <spanx style="verb">transparency_info</spanx> TLS extension. IANA should update this extension type to point at this document.
        </t>
      </section>
      <section title="Hash Algorithms" anchor="hash_algorithms">
        <t>
          IANA is asked to establish a registry of hash values, initially consisting of:
        </t>
        <texttable>
          <ttcol>Index</ttcol><ttcol>Hash</ttcol>
          <c>0</c><c><xref target="FIPS.180-4">SHA-256</xref></c>
        </texttable>
      </section>
      <section title="Signature Algorithms" anchor="signature_algorithms">
        <t>
          IANA is asked to establish a registry of signature algorithm values, initially consisting of:
        </t>
        <texttable>
          <ttcol>Index</ttcol><ttcol>Signature Algorithm</ttcol>
          <c>0</c><c><xref target="RFC6979">deterministic ECDSA</xref> using the NIST P-256 curve (Section D.1.2.3 of the <xref target="DSS">Digital Signature Standard </xref>) and HMAC-SHA256</c>
          <c>1</c><c>RSA signatures (RSASSA-PKCS1-v1_5 with SHA-256, Section 8.2 of <xref target="RFC3447"/>) using a key of at least 2048 bits.</c>
        </texttable>
      </section>
      <section title="SCT Extensions" anchor="sct_extension_types">
        <t>
          IANA is asked to establish a registry of SCT extensions, initially consisting of:
        </t>
        <texttable>
          <ttcol>Type</ttcol><ttcol>Extension</ttcol>
          <c>65535</c><c>reserved</c>
        </texttable>
        <t>
          TBD: policy for adding to the registry
        </t>
      </section>
      <section title="STH Extensions" anchor="sth_extension_types">
        <t>
          IANA is asked to establish a registry of STH extensions, initially consisting of:
        </t>
        <texttable>
          <ttcol>Type</ttcol><ttcol>Extension</ttcol>
          <c>65535</c><c>reserved</c>
        </texttable>
        <t>
          TBD: policy for adding to the registry
        </t>
      </section>
      <section title="Object Identifiers">
        <t>
          This document uses object identifiers (OIDs) to identify Log IDs (see <xref target="log_id"/>), the precertificate CMS <spanx style="verb">eContentType</spanx> (see <xref target="Precertificates"/>), and X.509v3 extensions in certificates (see <xref target="redacted_san_extension"/>, <xref target="name_constrained"/> and <xref target="cert_transinfo_extension"/>) and OCSP responses (see <xref target="ocsp_transinfo_extension"/>). The OIDs are defined in an arc that was selected due to its short encoding.
        </t>
        <section title="Log ID Registry 1" anchor="log_id_registry1">
          <t>
            All OIDs in the range from 1.3.101.8192 to 1.3.101.16383 have been reserved. This is a limited resource of 8,192 OIDs, each of which has an encoded length of 4 octets.
          </t>
          <t>
            IANA is requested to establish a registry that will allocate Log IDs from this range.
          </t>
          <t>
            TBD: policy for adding to the registry. Perhaps "Expert Review"?
          </t>
        </section>
        <section title="Log ID Registry 2" anchor="log_id_registry2">
          <t>
            The 1.3.101.80 arc has been delegated. This is an unlimited resource, but only the 128 OIDs from 1.3.101.80.0 to 1.3.101.80.127 have an encoded length of only 4 octets.
          </t>
          <t>
            IANA is requested to establish a registry that will allocate Log IDs from this arc.
          </t>
          <t>
            TBD: policy for adding to the registry. Perhaps "Expert Review"?
          </t>
        </section>
      </section>
    </section>

    <section title="Security Considerations">
      <t>
        With CAs, logs, and servers performing the actions described here, TLS clients can use logs and signed timestamps to reduce the likelihood that they will accept misissued certificates.  If a server presents a valid signed timestamp for a certificate, then the client knows that a log has committed to publishing the certificate.  From this, the client knows that monitors acting for the subject of the certificate have had some time to notice the misissue and take some action, such as asking a CA to revoke a misissued certificate, or that the log has misbehaved, which will be discovered when the SCT is audited.  A signed timestamp is not a guarantee that the certificate is not misissued, since appropriate monitors might not have checked the logs or the CA might have refused to revoke the certificate.
      </t>
      <t>
        In addition, if TLS clients will not accept unlogged certificates, then site owners will have a greater incentive to submit certificates to logs, possibly with the assistance of their CA, increasing the overall transparency of the system.
      </t>
      <t>
        <xref target="I-D.ietf-trans-threat-analysis"/> provides a more detailed threat analysis of the
        Certificate Transparency architecture.
      </t>
      <section title="Misissued Certificates">
        <t>
          Misissued certificates that have not been publicly logged, and thus do not have a valid SCT, are not considered compliant. Misissued certificates that do have an SCT from a log will appear in that public log within the Maximum Merge Delay, assuming the log is operating correctly. Thus, the maximum period of time during which a misissued certificate can be used without being available for audit is the MMD.
        </t>
      </section>
      <section title="Detection of Misissue">
        <t>
          The logs do not themselves detect misissued certificates; they rely instead on interested parties, such as domain owners, to monitor them and take corrective action when a misissue is detected.
        </t>
      </section>
      <section title="Avoiding Overly Redacting Domain Name Labels">
        <t>
          Redaction of domain name labels carries the same risks as the use of wildcards (See Section 7.2 of <xref target="RFC6125"/>, for example). If the entirety of the domain space below the unredacted part of a domain name is not registered by a single domain owner (e.g. <spanx style="verb">REDACT(label).com</spanx>, <spanx style="verb">REDACT(label).co.uk</spanx> and other <xref target="Public.Suffix.List">public suffixes</xref>), then the domain name may be considered by clients to be overly redacted.
        </t>
        <t>
          CAs should take care to avoid overly redacting domain names in precertificates. It is expected that monitors will treat precertificates that contain overly redacted domain names as potentially misissued. TLS clients MAY consider a certificate to be non-compliant if the <xref target="reconstructing_tbscertificate">reconstructed TBSCertificate</xref> contains any overly redacted domain names.
        </t>
      </section>
      <section title="Misbehaving Logs" anchor="misbehaving_logs">
        <t>
          A log can misbehave in several ways. Examples include failing to incorporate a certificate with an SCT in the Merkle Tree within the MMD, presenting different, conflicting views of the Merkle Tree at different times and/or to different parties and issuing STHs too frequently.
Such misbehavior is detectable and the <xref target="I-D.ietf-trans-threat-analysis"/> provides more details on how
this can be done.
        </t>
        <t>
          Violation of the MMD contract is detected by log clients requesting a
Merkle inclusion proof (<xref target="get-proof-by-hash"/>) for each observed SCT.
These checks can be asynchronous and
need only be done once per each certificate. In order to protect the clients'
privacy, these checks need not reveal the exact certificate to the log. Instead, clients
can request the proof from a trusted auditor (since anyone can compute
the proofs from the log) or communicate with the log via proxies.
        </t>
        <t>
          Violation of the append-only property or the STH issuance rate limit can be detected by clients comparing their instances of the Signed Tree Heads. There are various ways this could be done, for example via gossip (see <xref target="I-D.ietf-trans-gossip"/>) or peer-to-peer communications or by sending STHs to monitors (who could then directly check against their own copy of the relevant log). A proof of misbehavior in such cases would be a series of STHs that were issued too closely together, proving violation of the STH issuance rate limit, or an STH with a root hash that does not match the one calculated from a copy of the log, proving violation of the append-only property.
        </t>
      </section>
      <section title="Deterministic Signatures" anchor="deterministic_signatures">
        <t>
          Logs are required to use deterministic signatures for the following reasons:
          <list style="symbols">
            <t>
              Using non-deterministic ECDSA with a predictable source of randomness means that each signature can potentially expose the secret material of the signing key.
            </t>
            <t>
              Clients that gossip STHs or report back SCTs can be tracked or traced if a log was to produce multiple STHs or SCTs with the same timestamp and data but different signatures.
            </t>
          </list>
        </t>
      </section>
      <section title="Multiple SCTs">
        <t>
          By offering multiple SCTs, each from a different log, TLS servers reduce the effectiveness of an attack where a CA and a log collude (see <xref target="multiple-scts"/>).
        </t>
      </section>
    </section>
    <section title="Privacy Considerations">
      <section title="Ensuring Effective Redaction">
        <t>
          Although the domain name redaction mechanism (<xref target="domain_name_redaction"/>) removes the need for private labels to appear in logs, it does not guarantee that this will never happen. Anyone who encounters a certificate could choose to submit it to one or more logs, thereby rendering the redaction futile. Therefore, domain owners are advised to take the following steps to minimize the likelihood that their private labels will become known outside their closed communities:
          <list style="symbols">
            <t>
              Avoid registering private labels in public DNS.
            </t>
            <t>
              Avoid using private labels that are predictable (e.g. <spanx style="verb">www</spanx>).
            </t>
          </list>
        </t>
        <t>
          CAs are advised to carefully consider each request to redact a label. When a CA believes that redacting a particular label would be futile, we advise rejecting the redaction request. TLS clients may have policies that forbid redaction, so redaction should only be used when it's absolutely necessary and likely to be effective.
        </t>
      </section>
    </section>
    <section title="Acknowledgements">
      <t>
        The authors would like to thank Erwann Abelea, Robin Alden, Andrew Ayer, Al Cutter, Francis Dupont, Adam Eijdenberg, Stephen Farrell, Daniel Kahn Gillmor, Paul Hadfield, Brad Hill, Jeff Hodges, Paul Hoffman, Jeffrey Hutzelman, Kat Joyce, Stephen Kent, SM, Alexey Melnikov, Linus Nordberg, Chris Palmer, Trevor Perrin, Pierre Phaneuf, Melinda Shore, Ryan Sleevi, Martin Smith, Carl Wallace and Paul Wouters for their valuable contributions.
      </t>
      <t>
        A big thank you to Symantec for kindly donating the OIDs from the 1.3.101 arc that are used in this document.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">

      <?rfc include="reference.RFC.2119" ?>

      <?rfc include="reference.RFC.2616"?>

      <?rfc include="reference.RFC.3447"?>

      <?rfc include="reference.RFC.4627"?>

      <?rfc include="reference.RFC.4648"?>

      <?rfc include="reference.RFC.5246"?>

      <?rfc include="reference.RFC.5280"?>

      <?rfc include="reference.RFC.5652"?>

      <?rfc include="reference.RFC.5905"?>

      <?rfc include="reference.RFC.6066"?>

      <?rfc include="reference.RFC.6125"?>

      <?rfc include="reference.RFC.6960"?>

      <?rfc include="reference.RFC.6961"?>

      <?rfc include="reference.RFC.6979"?>

      <?rfc include="reference.RFC.7633"?>

      <reference anchor="DSS" target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf">
        <front>
          <title>Digital Signature Standard (DSS)</title>
          <author>
            <organization abbrev="NIST">National Institute of Standards and
Technology</organization>
          </author>
          <date month="June" year="2009"/>
        </front>
        <seriesInfo name="FIPS" value="186-3"/>
        <format type="PDF" target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf"/>
      </reference>

      <reference anchor="FIPS.180-4"
target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
        <front>
          <title>Secure Hash Standard</title>
          <author>
            <organization>National Institute of Standards and Technology</organization>
          </author>
          <date month="March" year="2012"/>
        </front>
        <seriesInfo name="FIPS" value="PUB 180-4"/>
      </reference>

      <reference anchor="HTML401" target="http://www.w3.org/TR/1999/REC-html401-19991224">
        <front>
          <title>HTML 4.01 Specification</title>
          <author initials="D." surname="Raggett" fullname="David Raggett">
            <organization/>
          </author>
          <author initials="A." surname="Le Hors" fullname="Arnaud Le Hors">
            <organization/>
          </author>
          <author initials="I." surname="Jacobs" fullname="Ian Jacobs">
            <organization/>
          </author>
          <date month="December" day="24" year="1999"/>
        </front>
        <seriesInfo name="World Wide Web Consortium Recommendation" value="REC-html401-19991224"/>
        <format type="HTML" target="http://www.w3.org/TR/1999/REC-html401-19991224"/>
      </reference>

    </references>

<references title="Informative References">

    <?rfc include="reference.RFC.6962"?>

    <?rfc include="reference.I-D.ietf-trans-gossip.xml"?>

      <reference anchor="CrosbyWallach"
target="http://static.usenix.org/event/sec09/tech/full_papers/crosby.pdf">
        <front>
          <title>Efficient Data Structures for Tamper-Evident Logging</title>
          <author initials='S.' surname='Crosby' fullname='Scott A. Crosby'>
            <organization/>
          </author>
          <author initials='D.' surname='Wallach' fullname='Dan S. Wallach'>
            <organization/>
          </author>
          <date month="August" year="2009"/>
        </front>
<seriesInfo name="Proceedings of the 18th USENIX Security Symposium,"
value="Montreal"/>
        <format type="PDF" target="http://static.usenix.org/event/sec09/tech/full_papers/crosby.pdf"/>
      </reference>

      <reference anchor="EVSSLGuidelines" target="https://cabforum.org/wp-content/uploads/EV_Certificate_Guidelines.pdf">
        <front>
          <title>Guidelines For The Issuance And Management Of Extended Validation Certificates</title>
          <author>
            <organization>CA/Browser Forum</organization>
          </author>
          <date year="2007"/>
        </front>
        <format type="PDF" target="https://cabforum.org/wp-content/uploads/EV_Certificate_Guidelines.pdf"/>
      </reference>

      <reference anchor="Chromium.Policy" target="http://www.chromium.org/Home/chromium-security/certificate-transparency">
        <front>
          <title>Chromium Certificate Transparency</title>
          <author>
            <organization>The Chromium Projects</organization>
          </author>
          <date year="2014"/>
        </front>
      </reference>

      <reference anchor="JSON.Metadata" target="http://www.certificate-transparency.org/known-logs/log_list_schema.json">
        <front>
          <title>Chromium Log Metadata JSON Schema</title>
          <author>
            <organization>The Chromium Projects</organization>
          </author>
          <date year="2014"/>
        </front>
      </reference>

      <reference anchor="Chromium.Log.Policy" target="http://www.chromium.org/Home/chromium-security/certificate-transparency/log-policy">
        <front>
          <title>Chromium Certificate Transparency Log Policy</title>
          <author>
            <organization>The Chromium Projects</organization>
          </author>
          <date year="2014"/>
        </front>
      </reference>

      <reference anchor="Public.Suffix.List" target="https://publicsuffix.org">
        <front>
          <title>Public Suffix List</title>
          <author>
            <organization>Mozilla Foundation</organization>
          </author>
          <date year="2016"/>
        </front>
      </reference>

      <?rfc include="reference.I-D.ietf-trans-threat-analysis.xml"?>

    </references>

    <section title="Supporting v1 and v2 simultaneously" anchor="v1_coexistence">
      <t>
        Certificate Transparency logs have to be either v1 (conforming to <xref target="RFC6962"/>) or v2 (conforming to this document), as the data structures are incompatible and so a v2 log could not issue a valid v1 SCT.
      </t>
      <t>
        CT clients, however, can support v1 and v2 SCTs, for the same certificate, simultaneously, as v1 SCTs are delivered in different TLS, X.509 and OCSP extensions than v2 SCTs.
      </t>
      <t>
        v1 and v2 SCTs for X.509 certificates can be validated independently.
        For precertificates, v2 SCTs should be embedded in the TBSCertificate before submission of the TBSCertificate (inside a v1 precertificate, as described in Section 3.1. of <xref target="RFC6962"/>) to a v1 log so that TLS clients conforming to <xref target="RFC6962"/> but not this document are oblivious to the embedded v2 SCTs.
        An issuer can follow these steps to produce an X.509 certificate with embedded v1 and v2 SCTs:
        <list style="symbols">
          <t>
            Create a CMS precertificate as described in <xref target="Precertificates"/> and submit it to v2 logs.
          </t>
          <t>
            Embed the obtained v2 SCTs in the TBSCertificate, as described in <xref target="cert_transinfo_extension"/>.
          </t>
          <t>
            Use that TBSCertificate to create a v1 precertificate, as described in Section 3.1. of <xref target="RFC6962"/> and submit it to v1 logs.
          </t>
          <t>
            Embed the v1 SCTs in the TBSCertificate, as described in Section 3.3. of <xref target="RFC6962"/>.
          </t>
          <t>
            Sign that TBSCertificate (which now contains v1 and v2 SCTs) to issue the final X.509 certificate.
          </t>
        </list>
      </t>
    </section>
  </back>
</rfc>
