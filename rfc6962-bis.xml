<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC ''
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<?rfc symrefs="yes"?>
<?rfc toc="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc sortrefs="yes" ?>

<rfc ipr="trust200902" category="std" submissionType="IETF" docName="draft-ietf-trans-rfc6962-bis-09">

  <front>
    <title>Certificate Transparency</title>
    <author initials="B" surname="Laurie" fullname="Ben Laurie">
      <organization abbrev="Google">
        Google UK Ltd.
      </organization>
      <address>
        <email>benl@google.com</email>
      </address>
    </author>
    <author initials="A" surname="Langley" fullname="Adam Langley">
      <organization abbrev="Google">
        Google Inc.
      </organization>
      <address>
        <email>agl@google.com</email>
      </address>
    </author>
    <author initials="E" surname="Kasper" fullname="Emilia Kasper">
      <organization abbrev="Google">
        Google Switzerland GmbH
      </organization>
      <address>
        <email>ekasper@google.com</email>
      </address>
    </author>
    <author initials="E" surname="Messeri" fullname="Eran Messeri">
      <organization abbrev="Google">
        Google UK Ltd.
      </organization>
      <address>
        <email>eranm@google.com</email>
      </address>
    </author>
    <author initials="R" surname="Stradling" fullname="Rob Stradling">
      <organization abbrev="Comodo">
        Comodo CA, Ltd.
      </organization>
      <address>
        <email>rob.stradling@comodo.com</email>
      </address>
    </author>
    <date />
    <workgroup>Public Notary Transparency Working Group</workgroup>

    <abstract>
      <t>
        This document describes a protocol for publicly logging
the existence of Transport Layer Security (TLS) certificates as they are issued
or observed, in a manner that allows anyone to audit certification authority (CA)
activity and notice the issuance of suspect certificates as well as to audit
the certificate logs themselves. The intent is that eventually clients would
refuse to honor certificates that do not appear in a log, effectively forcing
CAs to add all issued certificates to the logs.
      </t>
      <t>
        Logs are network services that implement the protocol operations for
submissions and queries that are defined in this document.
      </t>
    </abstract>
  </front>
  <middle>
    <section title="Introduction">
      <t>
        Certificate transparency aims to mitigate the problem of misissued
certificates by providing publicly auditable, append-only, untrusted logs of
all issued certificates. The logs are publicly auditable so that it is possible
for anyone to verify the correctness of each log and to monitor when new
certificates are added to it. The logs do not themselves prevent misissue, but
they ensure that interested parties (particularly those named in certificates)
can detect such misissuance. Note that this is a general mechanism, but in this
document, we only describe its use for public TLS server certificates issued by
public certification authorities (CAs).
      </t>
      <t>
        Each log consists of certificate chains, which can be submitted by
anyone. It is expected that public CAs will contribute all their newly issued
certificates to one or more logs, however certificate holders
can also contribute their own certificate chains, as can third parties. In order to avoid logs being
rendered useless by submitting large numbers of spurious certificates, it is required that each chain is rooted in a
CA certificate accepted by the log. When a chain is submitted to a log, a signed timestamp is
returned, which can later be used to provide evidence to TLS clients that the chain
has been submitted. TLS clients can thus require that all certificates they accept as valid are accompanied by signed timestamps.
      </t>
      <t>
        Those who are concerned about misissue can monitor the logs, asking
them regularly for all new entries, and can thus check whether domains they are
responsible for have had certificates issued that they did not expect. What
they do with this information, particularly when they find that a misissuance
has happened, is beyond the scope of this document, but broadly speaking, they
can invoke existing business mechanisms for dealing with misissued
certificates, such as working with the CA to get the certificate revoked, or with maintainers of trust anchor lists to get the CA removed. Of course, anyone who wants can monitor the logs and, if they
believe a certificate is incorrectly issued, take action as they see fit.
      </t>
      <t>
        Similarly, those who have seen signed timestamps from a particular log can later demand a proof of inclusion from that log. If the log is unable to provide this (or, indeed, if the corresponding certificate is absent from monitors' copies of that log), that is evidence of the incorrect operation of the log. The checking operation is asynchronous to allow TLS connections to proceed without delay, despite network connectivity issues and the vagaries of firewalls.
      </t>
      <t>
        The append-only property of each log is technically achieved using Merkle Trees, which can be used to show that any particular instance of the log is a superset of any particular previous instance. Likewise, Merkle Trees avoid the need to blindly trust logs: if a log attempts to show different things to different people, this can be efficiently detected by comparing tree roots and consistency proofs. Similarly, other misbehaviors of any log (e.g., issuing signed timestamps for certificates they then don't log) can be efficiently detected and proved to the world at large.
      </t>
      <section title="Requirements Language">
        <t>
          The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
        </t>
      </section>
      <section title="Data Structures">
        <t>
          Data structures are defined according to the conventions laid out in
Section 4 of <xref target="RFC5246"/>.
        </t>
      </section>
    </section>
    <section title="Cryptographic Components">
      <section title="Merkle Hash Trees" anchor="mht">
        <t>
          Logs use a binary Merkle Hash Tree for efficient auditing. The hashing algorithm used by each log is expected to be specified as part of the metadata relating to that log. We have established a registry of acceptable algorithms, see <xref target="hash_algorithms"/>. The hashing algorithm in use is referred to as HASH throughout this document and the size of its output in bytes as HASH_SIZE. The input to the Merkle Tree Hash is a list
of data entries; these entries will be hashed to form the leaves of the Merkle
Hash Tree. The output is a single HASH_SIZE Merkle Tree Hash. Given an ordered
list of n inputs, D[n] = {d(0), d(1), ..., d(n-1)}, the Merkle Tree Hash (MTH)
is thus defined as follows:
        </t>
        <t>
          The hash of an empty list is the hash of an empty string:
          <vspace blankLines='1' />
          MTH({}) = HASH().
          <vspace blankLines='1' />
          The hash of a list with one entry (also known as a leaf hash) is:
          <vspace blankLines='1' />
          MTH({d(0)}) = HASH(0x00 || d(0)).
          <vspace blankLines='1' />
          For n &gt; 1, let k be the largest power of two smaller than n (i.e., k &lt; n &lt;= 2k). The Merkle Tree Hash of an n-element list D[n] is then defined recursively as
          <vspace blankLines='1' />
          MTH(D[n]) = HASH(0x01 || MTH(D[0:k]) || MTH(D[k:n])),
          <vspace blankLines='1' />
          where || is concatenation and D[k1:k2] denotes the list {d(k1), d(k1+1),..., d(k2-1)} of length (k2 - k1). (Note that the hash calculations for leaves and nodes differ. This domain separation is required to give second preimage resistance.)
        </t>
        <t>
          Note that we do not require the length of the input list to be a
power of two. The resulting Merkle Tree may thus not be balanced; however, its
shape is uniquely determined by the number of leaves. (Note: This Merkle Tree is
essentially the same as the <xref target='CrosbyWallach'>history tree</xref>
proposal, except our definition handles non-full trees differently.)
        </t>
      <section title="Merkle Inclusion Proofs" anchor='merkle_inclusion_proof'>
        <t>
          A Merkle inclusion proof for a leaf in a Merkle Hash Tree is the shortest
list of additional nodes in the Merkle Tree required to compute the Merkle Tree
Hash for that tree. Each node in the tree is either a leaf node or is computed
from the two nodes immediately below it (i.e., towards the leaves). At each
step up the tree (towards the root), a node from the inclusion proof is combined
with the node computed so far. In other words, the inclusion proof consists of the
list of missing nodes required to compute the nodes leading from a leaf to the
root of the tree. If the root computed from the inclusion proof matches the true
root, then the inclusion proof proves that the leaf exists in the tree.
        </t>
        <t> Given an ordered list of n inputs to the tree, D[n] = {d(0), ..., d(n-1)}, the Merkle inclusion proof PATH(m, D[n]) for the (m+1)th input d(m), 0 &lt;= m &lt; n, is defined as follows:
        </t>
        <t>
          The proof for the single leaf in a tree with a one-element input list D[1] = {d(0)} is empty:
          <vspace blankLines='1' />
          PATH(0, {d(0)}) = {}
          <vspace blankLines='1' />
          For n &gt; 1, let k be the largest power of two smaller than n. The proof for the (m+1)th element d(m) in a list of n &gt; m elements is then defined recursively as
          <vspace blankLines='1' />
          PATH(m, D[n]) = PATH(m, D[0:k]) : MTH(D[k:n]) for m &lt; k; and
          <vspace blankLines='1' />
          PATH(m, D[n]) = PATH(m - k, D[k:n]) : MTH(D[0:k]) for m &gt;= k,
          <vspace blankLines='1' />
          where : is concatenation of lists and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
        </t>
      </section>

      <section title="Merkle Consistency Proofs" anchor='consistency'>
        <t>
          Merkle consistency proofs prove the append-only property of the tree. A Merkle consistency proof for a Merkle Tree Hash MTH(D[n]) and a previously advertised hash MTH(D[0:m]) of the first m leaves, m &lt;= n, is the list of nodes in the Merkle Tree required to verify that the first m inputs D[0:m] are equal in both trees. Thus, a consistency proof must contain a set of intermediate nodes (i.e., commitments to inputs) sufficient to verify MTH(D[n]), such that (a subset of) the same nodes can be used to verify MTH(D[0:m]). We define an algorithm that outputs the (unique) minimal consistency proof.
        </t>
        <t>
          Given an ordered list of n inputs to the tree, D[n] = {d(0), ..., d(n-1)}, the Merkle consistency proof PROOF(m, D[n]) for a previous Merkle Tree Hash MTH(D[0:m]), 0 &lt; m &lt; n, is defined as:
          <vspace blankLines='1' />
          PROOF(m, D[n]) = SUBPROOF(m, D[n], true)
          <vspace blankLines='1' />
          The subproof for m = n is empty if m is the value for which PROOF was originally requested (meaning that the subtree Merkle Tree Hash MTH(D[0:m]) is known):
          <vspace blankLines='1' />
          SUBPROOF(m, D[m], true) = {}
          <vspace blankLines='1' />
           The subproof for m = n is the Merkle Tree Hash committing inputs D[0:m]; otherwise:
          <vspace blankLines='1' />
          SUBPROOF(m, D[m], false) = {MTH(D[m])}
          <vspace blankLines='1' />
          For m &lt; n, let k be the largest power of two smaller than n. The subproof is then defined recursively.
          <vspace blankLines='1' />
If m &lt;= k, the right subtree entries D[k:n] only exist in the current tree. We prove that the left subtree entries D[0:k] are consistent and add a commitment to D[k:n]:
          <vspace blankLines='1' />
          SUBPROOF(m, D[n], b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n])
          <vspace blankLines='1' />
If m > k, the left subtree entries D[0:k] are identical in both trees. We prove that the right subtree entries D[k:n] are consistent and add a commitment to D[0:k].
          <vspace blankLines='1' />
          SUBPROOF(m, D[n], b) = SUBPROOF(m - k, D[k:n], false) : MTH(D[0:k])
          <vspace blankLines='1' />
          Here, : is a concatenation of lists, and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
        </t>
        <t>
          The number of nodes in the resulting proof is bounded above by ceil(log2(n)) + 1.
        </t>
      </section>

        <section title="Example">
          <figure>
            <preamble>
              The binary Merkle Tree with 7 leaves:
            </preamble>
            <artwork>
            hash
           /    \
          /      \
         /        \
        /          \
       /            \
      k              l
     / \            / \
    /   \          /   \
   /     \        /     \
  g       h      i      j
 / \     / \    / \     |
 a b     c d    e f     d6
 | |     | |    | |
d0 d1   d2 d3  d4 d5</artwork>
          </figure>
          <t>
            The inclusion proof for d0 is [b, h, l].
          </t>
          <t>
            The inclusion proof for d3 is [c, g, l].
          </t>
          <t>
            The inclusion proof for d4 is [f, j, k].
          </t>
          <t>
            The inclusion proof for d6 is [i, k].
          </t>
          <figure>
            <preamble>
              The same tree, built incrementally in four steps:
            </preamble>
            <artwork>
    hash0          hash1=k
    / \              /  \
   /   \            /    \
  /     \          /      \
  g      c         g       h
 / \     |        / \     / \
 a b     d2       a b     c d
 | |              | |     | |
d0 d1            d0 d1   d2 d3

          hash2                    hash
          /  \                    /    \
         /    \                  /      \
        /      \                /        \
       /        \              /          \
      /          \            /            \
     k            i          k              l
    / \          / \        / \            / \
   /   \         e f       /   \          /   \
  /     \        | |      /     \        /     \
 g       h      d4 d5    g       h      i      j
/ \     / \             / \     / \    / \     |
a b     c d             a b     c d    e f     d6
| |     | |             | |     | |    | |
d0 d1   d2 d3           d0 d1   d2 d3  d4 d5</artwork>
          </figure>
          <t>
            The consistency proof between hash0 and hash is PROOF(3, D[7]) = [c, d, g, l]. c, g are used to verify hash0, and d, l are additionally used to show hash is consistent with hash0.
          </t>
          <t>
            The consistency proof between hash1 and hash is PROOF(4, D[7]) =
[l]. hash can be verified using hash1=k and l.
          </t>
          <t>
            The consistency proof between hash2 and hash is PROOF(6, D[7]) = [i, j, k]. k, i are used to verify hash2, and j is additionally used to show hash is consistent with hash2.
          </t>
        </section>
        <section title="Signatures" anchor="signatures">
          <t>
            Various data structures are signed. A log MUST use either <xref target="RFC6979">deterministic ECDSA</xref> using the NIST P-256 curve (Section D.1.2.3 of the <xref
target="DSS">Digital Signature Standard </xref>) and HMAC-SHA256 or RSA signatures (RSASSA-PKCS1-v1_5 with SHA-256,
Section 8.2 of <xref target="RFC3447"/>) using a key of at least 2048 bits.
          </t>
        </section>
      </section>
    </section>
    <section title="Log Format and Operation">
      <t>
        Anyone can submit certificates to certificate logs for public auditing;
however, since certificates will not be accepted by TLS clients unless logged,
it is expected that certificate owners or their CAs will usually submit them. A
log is a single, append-only Merkle Tree of such certificates.
      </t>
      <t>
        When a valid certificate is submitted to a log, the log MUST return a Signed Certificate Timestamp (SCT). The SCT is the log's promise to incorporate the certificate in the Merkle Tree within a fixed amount of time known as the Maximum Merge Delay (MMD). If the log has previously seen the certificate, it MAY return the same SCT as it returned before (note that if a certificate was previously logged as a precertificate, then the precertificate's SCT would not be appropriate, instead a fresh SCT of type x509_entry should be generated). TLS servers MUST present an SCT from one or more logs to the TLS client together with the certificate. A certificate not accompanied by an SCT (either for the end-entity certificate or for a name-constrained intermediate the end-entity certificate chains to) MUST NOT be considered compliant by TLS clients.
      </t>
      <t>
        Periodically, each log appends all its new entries to the Merkle Tree and signs the root of the tree. The log MUST incorporate a certificate in its Merkle Tree within the Maximum Merge Delay period after the issuance of the SCT. When encountering an SCT, an Auditor can verify that the certificate was added to the Merkle Tree within that timeframe.
      </t>
      <t>
        Log operators MUST NOT impose any conditions on retrieving or sharing data from the log.
      </t>
      <section title="Log Entries">
        <t>
          In order to enable attribution of each logged certificate to its issuer, each submitted certificate MUST be accompanied by all additional certificates required to verify the certificate chain up to an accepted root certificate. The root certificate itself MAY be omitted from the chain submitted to the log server. The log SHALL allow retrieval of a list of accepted root certificates (this list might usefully be the union of root certificates trusted by major browser vendors).
        </t>
        <t>
          Alternatively, (root as well as intermediate) certification authorities
may preannounce a certificate to logs prior to issuance in order to incorporate
the SCT in the issued certificate. To do this, the CA submits a precertificate
that the log can use to create an entry that will be valid against the issued
certificate. A precertificate is a CMS <xref target="RFC5652"/>
<spanx style="verb">signed-data</spanx> object that contains a TBSCertificate
<xref target="RFC5280"/> in its
<spanx style="verb">SignedData.encapContentInfo.eContent</spanx> field,
identified by the OID &lt;TBD&gt; in the
<spanx style="verb">SignedData.encapContentInfo.eContentType</spanx> field.
This TBSCertificate MAY redact certain domain name labels that will be present
in the issued certificate (see <xref target="redacting_subdomains"/>) and MUST
NOT contain any SCTs, but it will be otherwise identical to the TBSCertificate
in the issued certificate.
<spanx style="verb">SignedData.signerInfos</spanx> MUST contain a signature from
the same (root or intermediate) CA that will ultimately issue the certificate.
This signature indicates the certification authority's intent to issue the
certificate. This intent is considered binding (i.e., misissuance of the
precertificate is considered equivalent to misissuance of the certificate).
As above, the precertificate submission MUST be accompanied by all the
additional certificates required to verify the chain up to an accepted root
certificate. This does not involve using the
<spanx style="verb">SignedData.certificates</spanx> field, so that field SHOULD
be omitted.
        </t>
        <t>
          The CMS object MUST be DER encoded. Note that, because of the structure of CMS, the signature on the CMS object will not be a valid X.509v3 signature and so cannot be used to construct a certificate from the precertificate.
        </t>
        <t>
          Logs MUST verify that the submitted certificate or precertificate has
a valid signature chain to an accepted root certificate, using the chain of
intermediate CA certificates provided by the submitter. Logs MUST accept
certificates that are fully valid according to <xref target="RFC5280">RFC 5280</xref> verification rules
and are submitted with such a chain. Logs MAY accept
certificates and precertificates that have expired, are not yet valid, have been
revoked, or are otherwise not fully valid according to RFC 5280 verification rules
in order to accommodate quirks of CA certificate-issuing software. However, logs
MUST reject certificates without a valid signature chain to an accepted root
certificate. Logs MUST also reject precertificates that are not valid DER encoded CMS <spanx style="verb">signed-data</spanx> objects.
        </t>
        <t>
          If a certificate is accepted and an SCT issued, the accepting log MUST store the entire chain used for verification. This chain MUST include the certificate or precertificate itself, the zero or more intermediate CA certificates provided by the submitter, and the root certificate used to verify the chain (even if it was omitted from the submission). The log MUST present this chain for auditing upon request. This chain is required to prevent a CA from avoiding blame by logging a partial or empty chain.
        </t>
        <figure>
          <preamble>
            Each certificate or precertificate entry in a log MUST include the following components:
          </preamble>
          <artwork>
    enum {
        x509_entry(0), precert_entry_V2(2), (65535)
    } LogEntryType;

    opaque ASN.1Cert&lt;1..2^24-1&gt;;

    struct {
        ASN.1Cert leaf_certificate;
        ASN.1Cert certificate_chain&lt;0..2^24-1&gt;;
    } X509ChainEntry;

    opaque CMSPrecert&lt;1..2^24-1&gt;;

    struct {
        CMSPrecert pre_certificate;
        ASN.1Cert precertificate_chain&lt;0..2^24-1&gt;;
    } PrecertChainEntryV2;</artwork>
        </figure>
        <t>
          Logs SHOULD limit the length of chain they will accept. The maximum chain length is specified in the log's metadata.
        </t>
        <t>
          <spanx style="verb">entry_type</spanx> is the type of this entry. Future revisions of this protocol may add new LogEntryType values. <xref target="client_messages"/> explains how clients should handle unknown entry types.
        </t>
        <t>
          <spanx style="verb">leaf_certificate</spanx> is the end-entity certificate submitted for auditing.
        </t>
        <t>
          <spanx style="verb">certificate_chain</spanx> is an array of additional certificates required to verify the end-entity certificate. The first certificate MUST certify the end-entity certificate. Each following certificate MUST directly certify the one preceding it. The final certificate MUST either be, or be issued by, a root certificate accepted by the log. If the end-entity certificate is a root certificate, then this array is empty.
        </t>
        <t>
          <spanx style="verb">pre_certificate</spanx> is the precertificate submitted for auditing.
        </t>
        <t>
          <spanx style="verb">precertificate_chain</spanx> is a chain of additional certificates required to verify the precertificate submission. The first certificate MUST certify the precertificate. Each following certificate MUST directly certify the one preceding it. The final certificate MUST be a root certificate accepted by the log.
        </t>
      </section>
      <section title="Private Domain Name Labels">
        <t>
          Some regard some DNS domain name labels within their registered
domain space as private and security sensitive. Even though these domains are
often only accessible within the domain owner's private network, it's common for
them to be secured using publicly trusted TLS server certificates. We define a mechanism to allow these private labels to not appear in public logs.
        </t>
        <section title="Wildcard Certificates">
          <t>
            A certificate containing a <xref target="RFC6125">DNS-ID</xref> of
<spanx style="verb">*.example.com</spanx> could be used to secure the domain
<spanx style="verb">topsecret.example.com</spanx>, without revealing the string
<spanx style="verb">topsecret</spanx> publicly.
          </t>
          <t>
            Since TLS clients only match the wildcard character to the complete
leftmost label of the DNS domain name (see Section 6.4.3 of
<xref target="RFC6125"/>), this approach would not work for a DNS-ID such as
<spanx style="verb">top.secret.example.com</spanx>.  Also, wildcard certificates
are prohibited in some cases, such as <xref target="EVSSLGuidelines">Extended
Validation Certificates</xref>.
          </t>
        </section>
        <section title="Redacting Domain Name Labels in Precertificates" anchor="redacting_subdomains">
          <t>
            When creating a precertificate, the CA MAY substitute one or more
labels in each DNS-ID with a corresponding number of
<spanx style="verb">?</spanx> labels. Every label to the left of a
<spanx style="verb">?</spanx> label MUST also be redacted. For example, if a
certificate contains a DNS-ID of
<spanx style="verb">top.secret.example.com</spanx>, then the corresponding
precertificate could contain <spanx style="verb">?.?.example.com</spanx>
instead, but not <spanx style="verb">top.?.example.com</spanx> instead.
          </t>
          <t>
            Wildcard <spanx style="verb">*</spanx> labels MUST NOT be redacted.
However, if the complete leftmost label of a DNS-ID is
<spanx style="verb">*</spanx>, it is considered redacted for the purposes of
determining if the label to the right may be redacted. For example, if a
certificate contains a DNS-ID of
<spanx style="verb">*.top.secret.example.com</spanx>, then the corresponding
precertificate could contain
<spanx style="verb">*.?.?.example.com</spanx> instead, but not
<spanx style="verb">?.?.?.example.com</spanx> instead.
          </t>
          <t>
            When a precertificate contains one or more redacted labels, a
non-critical extension (OID 1.3.6.1.4.1.11129.2.4.6, whose extnValue OCTET STRING
contains an ASN.1 SEQUENCE OF INTEGERs) MUST be added to the corresponding
certificate: the first INTEGER indicates the total number of redacted labels
and wildcard <spanx style="verb">*</spanx> labels in the
precertificate's first DNS-ID; the second INTEGER does the same for the
precertificate's second DNS-ID; etc. There MUST NOT be more INTEGERs than there
are DNS-IDs. If there are fewer INTEGERs than there are DNS-IDs, the shortfall
is made up by implicitly repeating the last INTEGER. Each INTEGER MUST have a
value of zero or more. The purpose of this extension is to enable TLS clients
to accurately reconstruct the TBSCertificate component of the precertificate
from the certificate without having to perform any guesswork.
          </t>
          <t>
            When a precertificate contains that extension and contains a
<xref target="RFC6125">CN-ID</xref>, the CN-ID MUST match the first DNS-ID and
have the same labels redacted.  TLS clients will use the first
entry in the SEQUENCE OF INTEGERs to reconstruct both the first DNS-ID and the
CN-ID.
          </t>
        </section>
        <section title="Using a Name-Constrained Intermediate CA" anchor="name_constrained">
          <t>
            An intermediate CA certificate or intermediate CA precertificate that contains the
critical or non-critical <xref target="RFC5280">Name Constraints</xref> extension
MAY be logged in place of end-entity certificates issued by that intermediate
CA, as long as all of the following conditions are met:
            <list style="symbols">
              <t>
                there MUST be a non-critical extension (OID 1.3.6.1.4.1.11129.2.4.7,
whose extnValue OCTET STRING contains ASN.1 NULL data (0x05 0x00)). This
extension is an explicit indication that it is acceptable to not log
certificates issued by this intermediate CA.
              </t>
              <t>
                permittedSubtrees MUST specify one or more dNSNames.
              </t>
              <t>
                excludedSubtrees MUST specify the entire IPv4 and IPv6 address
ranges.
              </t>
            </list>
          </t>
          <figure>
            <preamble>
              Below is an example Name Constraints extension that meets these conditions:
            </preamble>
            <artwork>
    SEQUENCE {
      OBJECT IDENTIFIER '2 5 29 30'
      OCTET STRING, encapsulates {
        SEQUENCE {
          [0] {
            SEQUENCE {
              [2] 'example.com'
              }
            }
          [1] {
            SEQUENCE {
              [7] 00 00 00 00 00 00 00 00
              }
            SEQUENCE {
              [7]
                00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
                00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
              }
            }
          }
        }
      }</artwork>
          </figure>
        </section>
      </section>
      <section title="Structure of the Signed Certificate Timestamp">
        <figure>
          <artwork>
    enum {
        certificate_timestamp(0), tree_hash(1), (255)
    } SignatureType;

    enum {
        v2(1), (255)
    } Version;

    struct {
        opaque key_id[HASH_SIZE];
    } LogID;

    opaque TBSCertificate&lt;1..2^24-1&gt;;

    struct {
        opaque issuer_key_hash[HASH_SIZE];
        TBSCertificate tbs_certificate;
    } CertInfo;

    enum {
        reserved(65535)
    } SctExtensionType;

    struct {
        SctExtensionType sct_extension_type;
        opaque sct_extension_data&lt;0..2^16-1&gt;;
    } SctExtension;

    SctExtension SctExtensions&lt;0..2^16-1&gt;;</artwork>
        </figure>
        <t>
          <spanx style="verb">key_id</spanx> is the HASH of the log's public key, calculated over the DER encoding of the key represented as SubjectPublicKeyInfo.
        </t>
        <t>
          <spanx style="verb">issuer_key_hash</spanx> is the HASH of the certificate issuer's public key, calculated over the DER encoding of the key represented as SubjectPublicKeyInfo. This is needed to bind the issuer to the final certificate, making it impossible for the SCT to be valid for any other certificate.
        </t>
        <t>
          <spanx style="verb">tbs_certificate</spanx> is the DER-encoded
TBSCertificate component of the precertificate. Note that it is also possible to
reconstruct this TBSCertificate from the issued certificate by extracting the
TBSCertificate from it, redacting the domain name labels indicated by the
redacted labels extension, and deleting the SCT list extension and redacted
labels extension.
        </t>
        <t>
          <spanx style="verb">sct_extension_type</spanx> identifies a single extension from the IANA registry in <xref target="sct_extension_types"/>.
        </t>
        <t>
          The interpretation of the <spanx style="verb">sct_extension_data</spanx> field is determined solely by the value of the <spanx style="verb">sct_extension_type</spanx> field. Each document that registers a new <spanx style="verb">sct_extension_type</spanx> must describe how to interpret the corresponding <spanx style="verb">sct_extension_data</spanx>.
        </t>
        <t>
          The <spanx style="verb">SctExtensions</spanx> type is a vector of 0 or more extensions. This vector MUST NOT include more than one extension with the same <spanx style="verb">sct_extension_type</spanx>. The extensions in the vector MUST be ordered by the value of the <spanx style="verb">sct_extension_type</spanx> field, smallest value first.
        </t>
        <figure>
          <artwork>
    struct {
        Version sct_version;
        LogID id;
        uint64 timestamp;
        SctExtensions extensions;
        digitally-signed struct {
            Version sct_version;
            SignatureType signature_type = certificate_timestamp;
            uint64 timestamp;
            LogEntryType entry_type;
            select(entry_type) {
                case x509_entry: CertInfo;
                case precert_entry_V2: CertInfo;
            } signed_entry;
            SctExtensions extensions;
        };
    } SignedCertificateTimestamp;</artwork>
        </figure>
        <t>
          The encoding of the digitally-signed element is defined in <xref target='RFC5246'/>.
        </t>
        <t>
          <spanx style="verb">sct_version</spanx> is the version of the
protocol to which the SCT conforms. This version is v2. Note that <xref target="RFC6962">SignedCertificateTimestamp v1</xref> had a different definition of <spanx style="verb">signed_entry</spanx>.
        </t>
        <t>
          <spanx style="verb">timestamp</spanx> is the current <xref target="RFC5905">NTP Time</xref>, measured since the epoch (January 1, 1970, 00:00), ignoring leap seconds, in milliseconds.
        </t>
        <t>
          <spanx style="verb">entry_type</spanx> may be implicit from the context in which the SCT is presented.
        </t>
        <t>
          <spanx style="verb">signed_entry</spanx> includes the TBSCertificate from either the <spanx style="verb">leaf_certificate</spanx> (in the case of an X509ChainEntry) or the <spanx style="verb">pre_certificate</spanx> (in the case of a PrecertChainEntryV2).
        </t>
        <t>
          <spanx style="verb">extensions</spanx> are future extensions to SignedCertificateTimestamp v2. Currently, no extensions are specified. If an implementation sees an extension that it does not understand, it SHOULD ignore that extension. Furthermore, an implementation MAY choose to ignore any extension(s) that it does understand.
        </t>
      </section>
      <section title="Including the Signed Certificate Timestamp in the TLS Handshake">
        <t>
          The SCT data corresponding to at least one certificate in the chain
from at least one log must be included in the TLS handshake by using one or more
of the mechanisms listed below. Three mechanisms are provided because they have
different tradeoffs. TLS clients MUST implement all three mechanisms. TLS
servers MUST present SCTs using at least one of the three mechanisms.
          <list style="symbols">
            <t>
              A TLS extension (Section 7.4.1.4 of <xref target='RFC5246'/>) with
type <spanx style="verb">signed_certificate_timestamp</spanx>
(see <xref target="tls_sctlist_extension"/>). This mechanism allows TLS servers
to participate in CT without the cooperation of CAs, unlike the other two
mechanisms. It also allows SCTs to be updated on the fly.
            </t>
            <t>
              An <xref target='RFC6960'>Online Certificate Status Protocol
(OCSP)</xref> response extension (see <xref target="ocsp_sctlist_extension"/>),
where the OCSP response is provided in the
<spanx style="verb">certificate_status</spanx> TLS extension (Section 8 of
<xref target='RFC6066'/>), also known as OCSP stapling. This mechanism is
already widely (but not universally) implemented. It also allows SCTs to be
updated on the fly.
            </t>
            <t>
              An X509v3 certificate extension
(see <xref target="cert_sctlist_extension"/>). This mechanism allows the use of unmodified TLS servers, but the SCTs cannot be updated on the fly. Since the logs that signed the SCTs won't necessarily be accepted by TLS clients for the full lifetime of the certificate, there is a risk that TLS clients will subsequently consider the certificate to be non-compliant and in need of re-issuance.
            </t>
          </list>
        </t>
        <t>
          TLS servers SHOULD send SCTs from multiple logs in case one or more
logs are not acceptable to the TLS client (for example, if a log has been struck
off for misbehavior, has had a key compromise or is not known to the TLS
client).
        </t>
        <figure>
          <preamble>
            Multiple SCTs are combined into an SCT list as follows:
          </preamble>
          <artwork>
    opaque SerializedSCT&lt;1..2^16-1&gt;;

    struct {
        SerializedSCT sct_list&lt;1..2^16-1&gt;;
    } SignedCertificateTimestampList;</artwork>
        </figure>
        <t>
          Here, <spanx style="verb">SerializedSCT</spanx> is an opaque
byte string that contains the serialized SCT structure. This encoding ensures
that TLS clients can decode each SCT individually (i.e., if there is a version
upgrade, out-of-date clients can still parse old SCTs while skipping over new
SCTs whose versions they don't understand).
        </t>
        <section title="TLS Extension" anchor="tls_sctlist_extension">
          <t>
            One or more SCTs can be sent during the TLS handshake using a TLS
extension with type <spanx style="verb">signed_certificate_timestamp</spanx>.
          </t>
          <t>
            TLS clients that support the extension SHOULD send a ClientHello
extension with the appropriate type and empty
<spanx style="verb">extension_data</spanx>.
          </t>
          <t>
            TLS servers MUST only send SCTs in this TLS extension to TLS clients
that have indicated support for the extension in the ClientHello, in which case
the SCTs are sent by setting the <spanx style="verb">extension_data</spanx>
to a <spanx style="verb">SignedCertificateTimestampList</spanx>.
          </t>
          <t>
            Session resumption uses the original session information: TLS
clients SHOULD include the extension type in the ClientHello, but if the session
is resumed, the TLS server is not expected to process it or include the
extension in the ServerHello.
          </t>
        </section>
        <section title="X.509v3 Extension" anchor="x509v3_extension">
          <t>
            One or more SCTs can be embedded in an X.509v3 extension that is
included in a certificate or an OCSP response. Since RFC5280 requires the
<spanx style="verb">extnValue</spanx> field (an OCTET STRING) of each X.509v3
extension to include the DER encoding of an ASN.1 value, we cannot embed a
<spanx style="verb">SignedCertificateTimestampList</spanx> directly.
Instead, we have to wrap it inside an additional OCTET STRING (see below),
which we then put into the <spanx style="verb">extnValue</spanx> field.
          </t>
          <section title="OCSP Response Extension" anchor="ocsp_sctlist_extension">
            <figure>
              <preamble>
                A certification authority may embed one or more SCTs in OCSP responses pertaining to the end-entity certificate, by including a non-critical <spanx style="verb">singleExtensions</spanx> extension with OID 1.3.6.1.4.1.11129.2.4.5 whose <spanx style="verb">extnValue</spanx> contains:
              </preamble>
              <artwork>
    CertificateSCTList ::= OCTET STRING</artwork>
            </figure>
            <t>
              <spanx style="verb">CertificateSCTList</spanx> contains a
<spanx style="verb">SignedCertificateTimestampList</spanx> whose SCTs all have
the <spanx style="verb">x509_entry</spanx>
<spanx style="verb">LogEntryType</spanx>.
            </t>
          </section>
          <section title="Certificate Extension" anchor="cert_sctlist_extension">
            <figure>
              <preamble>
                A certification authority that has submitted a precertificate to one or more logs may embed the obtained SCTs in the <spanx style="verb">TBSCertificate</spanx> that will be signed to produce the certificate, by including a non-critical X.509v3 extension with OID 1.3.6.1.4.1.11129.2.4.2 whose <spanx style="verb">extnValue</spanx> contains:
              </preamble>
              <artwork>
    PrecertificateSCTList ::= OCTET STRING</artwork>
            </figure>
            <t>
              <spanx style="verb">PrecertificateSCTList</spanx> contains a
<spanx style="verb">SignedCertificateTimestampList</spanx> whose SCTs all have
the <spanx style="verb">precert_entry_V2</spanx>
<spanx style="verb">LogEntryType</spanx>.
            </t>
            <t>
              Upon receiving the certificate, clients can reconstruct the
original <spanx style="verb">TBSCertificate</spanx> to verify the SCT
signatures.
            </t>
          </section>
        </section>
      </section>
      <section title="Merkle Tree" anchor="tree">
        <t>
          The hashing algorithm for the Merkle Tree Hash is specified in the log's metadata.
        </t>
        <figure>
          <preamble>
            Structure of the Merkle Tree input:
          </preamble>
          <artwork>
    enum {
        v1(0), v2(1), (255)
    } LeafVersion;

    struct {
        uint64 timestamp;
        LogEntryType entry_type;
        select(entry_type) {
            case x509_entry: CertInfo;
            case precert_entry_V2: CertInfo;
        } signed_entry;
        SctExtensions extensions;
    } TimestampedEntry;

    struct {
        LeafVersion version;
        TimestampedEntry timestamped_entry;
    } MerkleTreeLeaf;</artwork>
        </figure>
        <t>
          Here, <spanx style="verb">version</spanx> is the version of the MerkleTreeLeaf structure. This version is v2. Note that <xref target="RFC6962">MerkleTreeLeaf v1</xref> had another layer of indirection which is removed in v2.
        </t>
        <t>
          <spanx style="verb">timestamp</spanx> is the timestamp of the corresponding SCT issued for this certificate.
        </t>
        <t>
          <spanx style="verb">entry_type</spanx> is the type of entry stored in <spanx style="verb">signed_entry</spanx>. New <spanx style="verb">LogEntryType</spanx> values may be added to <spanx style="verb">signed_entry</spanx> without increasing the <spanx style="verb">MerkleTreeLeaf</spanx> version. <xref target="client_messages"/> explains how clients should handle unknown entry types.
        </t>
        <t>
          <spanx style="verb">signed_entry</spanx> is the <spanx style="verb">signed_entry</spanx> of the corresponding SCT.
        </t>
        <t>
          <spanx style="verb">extensions</spanx> are the <spanx style="verb">extensions</spanx> of the corresponding SCT.
        </t>
        <t>
          The leaves of the Merkle Tree are the leaf hashes of the corresponding <spanx style="verb">MerkleTreeLeaf</spanx> structures. Note that <xref target="mht">leaf hashes</xref> are calculated as HASH(0x00 || MerkleTreeLeaf).
        </t>
      </section>
      <section title="Signed Tree Head (STH)" anchor="STH">
        <t>
          Periodically the log SHOULD sign the corresponding tree hash and tree information (see the corresponding Signed Tree Head client message in <xref target="fetch_sth"/>).
        </t>
        <t>
          Each log MUST produce on demand a Signed Tree Head that is no older than the Maximum Merge Delay. However, Signed Tree Heads could be used to mark individual clients (by producing a new one for each query), so logs MUST NOT produce them more frequently than is declared in their metadata. In general, there is no need to produce a new Signed Tree Head unless there are new entries in the log, however, in the unlikely event that it receives no new submissions during an MMD period, the log SHALL sign the same Merkle Tree Hash with a fresh timestamp.
        </t>
        <section title="Structure of the STH" anchor="sth_struct">
          <figure>
            <artwork>
    enum {
        v2(1), (255)
    } TreeHeadVersion;

    enum {
        reserved(65535)
    } SthExtensionType;

    struct {
        SthExtensionType sth_extension_type;
        opaque sth_extension_data&lt;0..2^16-1&gt;;
    } SthExtension;

    SthExtension SthExtensions&lt;0..2^16-1&gt;;</artwork>
          </figure>
          <t>
            <spanx style="verb">sth_extension_type</spanx> identifies a single extension from the IANA registry in <xref target="sth_extension_types"/>.
          </t>
          <t>
            The interpretation of the <spanx style="verb">sth_extension_data</spanx> field is determined solely by the value of the <spanx style="verb">sth_extension_type</spanx> field. Each document that registers a new <spanx style="verb">sth_extension_type</spanx> must describe how to interpret the corresponding <spanx style="verb">sth_extension_data</spanx>.
          </t>
          <t>
            The <spanx style="verb">SthExtensions</spanx> type is a vector of 0 or more extensions. This vector MUST NOT include more than one extension with the same <spanx style="verb">sth_extension_type</spanx>. The extensions in the vector MUST be ordered by the value of the <spanx style="verb">sth_extension_type</spanx> field, smallest value first.
          </t>
          <figure>
            <artwork>
    struct {
        TreeHeadVersion version;
        LogID id;
        uint64 timestamp;
        uint64 tree_size;
        opaque root_hash[HASH_SIZE];
        SthExtensions extensions;
        digitally-signed struct {
            TreeHeadVersion version;
            SignatureType signature_type = tree_hash;
            LogID id;
            uint64 timestamp;
            uint64 tree_size;
            opaque root_hash[HASH_SIZE];
            SthExtensions extensions;
        };
    } SignedTreeHead;</artwork>
         </figure>
          <t>
            <spanx style="verb">version</spanx> is the version of the SignedTreeHead structure. This version is v2. Note that <xref target="RFC6962">TreeHeadSignature v1</xref> only included the inner <spanx style="verb">digitally-signed struct</spanx> and did not include the <spanx style="verb">id</spanx> or <spanx style="verb">extensions</spanx> fields.
          </t>
          <t>
            <spanx style="verb">timestamp</spanx> is the current NTP Time [RFC5905], measured since the epoch (January 1, 1970, 00:00), ignoring leap seconds, in milliseconds. The timestamp MUST be at least as recent as the most recent SCT timestamp in the tree. Each subsequent timestamp MUST be more recent than the timestamp of the previous update.
          </t>
          <t>
            <spanx style="verb">tree_size</spanx> equals the number of entries in the new tree.
          </t>
          <t>
            <spanx style="verb">root_hash</spanx> is the root of the Merkle Hash Tree.
          </t>
          <t>
            <spanx style="verb">extensions</spanx> are future extensions to SignedTreeHead v2. Currently, no extensions are specified. If an implementation sees an extension that it does not understand, it SHOULD ignore that extension. Furthermore, an implementation MAY choose to ignore any extension(s) that it does understand.
          </t>
        </section>
      </section>
    </section>
    <section title="Log Client Messages" anchor="client_messages">
      <t>
        Messages are sent as HTTPS GET or POST requests. Parameters for POSTs
and all responses are encoded as <xref target="RFC4627">JavaScript Object
Notation (JSON)
objects</xref>. Parameters for GETs are encoded as order-independent key/value
URL parameters, using the "application/x-www-form-urlencoded" format described
in the <xref target="HTML401">"HTML 4.01 Specification"</xref>. Binary data is
<xref target="RFC4648">base64 encoded</xref> as specified in the individual
messages.
      </t>
      <t>
        Note that JSON objects and URL parameters may contain fields not specified here. These extra fields should be ignored.
      </t>
      <t>
        The &lt;log server&gt; prefix MAY include a path as well as a server name and a port.
      </t>
      <t>
        In general, where needed, the <spanx style="verb">version</spanx> is v1 and the <spanx style="verb">id</spanx> is the log id for the log server queried.
      </t>
      <t>
        In practice, log servers may include multiple front-end machines. Since it is impractical to keep these machines in perfect sync, errors may occur that are caused by skew between the machines. Where such errors are possible, the front-end will return additional information (as specified below) making it possible for clients to make progress, if progress is possible. Front-ends MUST only serve data that is free of gaps (that is, for example, no front-end will respond with an STH unless it is also able to prove consistency from all log entries logged within that STH).
      </t>
      <t>
        For example, when a consistency proof between two STHs is requested, the front-end reached may not yet be aware of one or both STHs. In the case where it is unaware of both, it will return the latest STH it is aware of. Where it is aware of the first but not the second, it will return the latest STH it is aware of and a consistency proof from the first STH to the returned STH. The case where it knows the second but not the first should not arise (see the "no gaps" requirement above).
      </t>
      <t>
        If the log is unable to process a client's request, it MUST return an HTTP response code of 4xx/5xx (see <xref target="RFC2616"/>), and, in place of the responses outlined in the subsections below, the body SHOULD be a JSON structure containing at least the following field:
        <list style="hanging">
          <t hangText="error_message:">
                A human-readable string describing the error which prevented the log from processing the request.
          </t>
          <t>
                In the case of a malformed request, the string SHOULD provide sufficient detail for the error to be rectified.
          </t>
          <t hangText="error_code:">
            An error code readable by the client. Some codes are generic and are detailed here. Others are detailed in the individual requests. Error codes are fixed text strings.
            <list style="hanging">
              <t hangText="not compliant">
                The request is not compliant with this RFC.
              </t>
            </list>
          </t>
        </list>
      </t>
      <figure>
        <preamble>
          e.g. In response to a request of <spanx style="verb">/ct/v2/get-entries?start=100&amp;end=99</spanx>, the log would return a <spanx style="verb">400 Bad Request</spanx> response code with a body similar to the following:
        </preamble>
        <artwork>
    {
        "error_message": "'start' cannot be greater than 'end'",
        "error_code": "not compliant",
    }</artwork>
      </figure>
      <t>
        Clients SHOULD treat <spanx style="verb">500 Internal Server Error</spanx> and <spanx style="verb">503 Service Unavailable</spanx> responses as transient failures and MAY retry the same request without modification at a later date.  Note that as per <xref target="RFC2616"/>, in the case of a 503 response the log MAY include a <spanx style="verb">Retry-After:</spanx> header in order to request a minimum time for the client to wait before retrying the request.
      </t>
      <section title="Add Chain to Log" anchor="sct">
        <t>
          POST https://&lt;log server&gt;/ct/v2/add-chain
        </t>
        <t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="chain:">
                  An array of base64 encoded certificates. The first element is the end-entity certificate; the second chains to the first and so on to the last, which is either the root certificate or a certificate that chains to a known root certificate.
                </t>
              </list>
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="sct:">
                  The base64 encoded <spanx style="verb">SignedCertificateTimestamp</spanx> for the submitted certificate.
                </t>
              </list>
            </t>
            <t hangText="Error codes:">
              <list style="hanging">
                <t hangText="unknown root">
                  The root of the chain is not one accepted by the log.
                </t>
                <t hangText="bad chain">
                  The alleged chain is not actually a chain of certificates.
                </t>
                <t hangText="bad certificate">
                  One or more certificates in the chain are not valid (e.g. not properly encoded).
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>
          If the version of <spanx style="verb">sct</spanx> is not v2, then a v2 client may be unable to verify the signature. It MUST NOT construe this as an error. This is to avoid forcing an upgrade of compliant v2 clients that do not use the returned SCTs.
        </t>
        <t>
          If a log detects bad encoding in a chain that otherwise verifies correctly then the log MAY still log the certificate but SHOULD NOT return an SCT. It should instead return the "bad certificate" error. Logging the certificate is useful, because <xref target="monitor">monitors</xref> can then detect these encoding errors, which may be accepted by some TLS clients.
        </t>
        <t>
          Note that not all certificate handling software is capable of detecting all encoding errors (e.g. some software will accept BER instead of DER encodings in certificates, or incorrect character encodings, even though these are technically incorrect) .
        </t>
      </section>

      <section title="Add PreCertChain to Log">
        <t>
          POST https://&lt;log server&gt;/ct/v2/add-pre-chain
        </t>
        <t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="precertificate:">
                  The base64 encoded precertificate.
                </t>
                <t hangText="chain:">
                  An array of base64 encoded CA certificates. The first element is
the signer of the precertificate; the second chains to the first and so on to
the last, which is either the root certificate or a certificate that chains to
an accepted root certificate.
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>
          Outputs and errors are the same as in <xref target="sct"/>.
        </t>
      </section>

      <section title="Retrieve Latest Signed Tree Head" anchor="fetch_sth">
        <t>
          GET https://&lt;log server&gt;/ct/v2/get-sth
        </t>
        <t>
          No inputs.
        </t>
        <t>
          <list style="hanging">
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="sth:">
                  A base64 encoded SignedTreeHead.
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>

      <section title="Retrieve Merkle Consistency Proof between Two Signed Tree Heads" anchor="fetch_consistency">
        <t>
          GET https://&lt;log server&gt;/ct/v2/get-sth-consistency
        </t>
        <t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="first:">
                  The tree_size of the older tree, in decimal.
                </t>
                <t hangText="second:">
                  The tree_size of the newer tree, in decimal (optional).
                </t>
              </list>
            </t>
            <t>
              Both tree sizes must be from existing v2 STHs (Signed Tree Heads). However, because of skew, the receiving front-end may not know one or both of the existing STHs. If both are known, then only the <spanx style="verb">consistency</spanx> output is returned. If the first is known but the second is not (or has been omitted), then the latest known STH is returned, along with a consistency proof between the first STH and the latest. If neither are known, then the latest known STH is returned without a consistency proof.
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="consistency:">
                  An array of base64 encoded Merkle Tree nodes.
                </t>
                <t hangText="sth:">
                  A base64 encoded SignedTreeHead.
                </t>
              </list>
            </t>
            <t>
              Note that no signature is required for the <spanx style="verb">consistency</spanx> output as it is used to verify <spanx style="verb">sth</spanx>, which is signed.
            </t>
            <t hangText="Error codes:">
              <list style="hanging">
                <t hangText="first unknown">
                  <spanx style="verb">first</spanx> is before the latest known STH but is not from an existing STH.
                </t>
                <t hangText="second unknown">
                  <spanx style="verb">second</spanx> is before the latest known STH but is not from an existing STH.
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>See <xref target="verify_consistency" /> for an outline of how to use the <spanx style="verb">consistency</spanx> array.</t>
      </section>

      <section title="Retrieve Merkle Inclusion Proof from Log by Leaf Hash" anchor="fetch_proof">
        <t>
          GET https://&lt;log server&gt;/ct/v2/get-proof-by-hash
        </t>
        <t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="hash:">
                  A base64 encoded v1 leaf hash.
                </t>
                <t hangText="tree_size:">
                  The tree_size of the tree on which to base the proof, in decimal.
                </t>
              </list>
            </t>
            <t>
              The <spanx style="verb">hash</spanx> must be calculated as defined in <xref target="tree"/>. The <spanx style="verb">tree_size</spanx> must designate an existing v2 STH. Because of skew, the front-end may not know the requested STH. In that case, it will return the latest STH it knows, along with an inclusion proof to that STH. If the front-end knows the requested STH then only <spanx style="verb">leaf_index</spanx> and <spanx style="verb">audit_path</spanx> are returned.
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="leaf_index:">
                  The 0-based index of the entry corresponding to the <spanx style="verb">hash</spanx> parameter.
                </t>
                <t hangText="audit_path:">
                  An array of base64 encoded Merkle Tree nodes proving the inclusion of the chosen certificate.
                </t>
                <t hangText="sth:">
                  A base64 encoded SignedTreeHead.
                </t>
              </list>
            </t>
            <t>
              Note that no signature is required for the <spanx style="verb">leaf_index</spanx> or <spanx style="verb">audit_path</spanx> outputs as they are used to verify inclusion in <spanx style="verb">sth</spanx>, which is signed.
            </t>
            <t hangText="Error codes:">
              <list style="hanging">
                <t hangText="hash unknown">
                  <spanx style="verb">hash</spanx> is not the hash of a known leaf (may be caused by skew or by a known certificate not yet merged).
                </t>
                <t hangText="tree_size unknown">
                  <spanx style="verb">hash</spanx> is before the latest known STH but is not from an existing STH.
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>See <xref target="verify_inclusion" /> for an outline of how to use the <spanx style="verb">audit_path</spanx> array.</t>
      </section>

      <section title="Retrieve Merkle Inclusion Proof, Signed Tree Head and Consistency Proof by Leaf Hash">
        <t>
          GET https://&lt;log server&gt;/ct/v2/get-all-by-hash
        </t>
        <t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="hash:">
                  A base64 encoded v1 leaf hash.
                </t>
                <t hangText="tree_size:">
                  The tree_size of the tree on which to base the proofs, in decimal.
                </t>
              </list>
            </t>
            <t>
              The <spanx style="verb">hash</spanx> must be calculated as defined in <xref target="tree"/>. The <spanx style="verb">tree_size</spanx> must designate an existing v2 STH.
            </t>
            <t>
              Because of skew, the front-end may not know the requested STH or the requested hash, which leads to a number of cases.
            </t>
            <t>
              <list style="hanging">
                <t hangText="latest STH &lt; requested STH">
                  Return latest STH.
                </t>
                <t hangText="latest STH &gt; requested STH">
                  Return latest STH and a consistency proof between it and the requested STH (see <xref target="fetch_consistency"/>).
                </t>
                <t hangText="index of requested hash &lt; latest STH">
                  Return <spanx style="verb">leaf_index</spanx> and <spanx style="verb">audit_path</spanx>.
                </t>
              </list>
            </t>
            <t>
              Note that more than one case can be true, in which case the returned data is their concatenation. It is also possible for none to be true, in which case the front-end MUST return an empty response.
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="leaf_index:">
                  The 0-based index of the entry corresponding to the <spanx style="verb">hash</spanx> parameter.
                </t>
                <t hangText="audit_path:">
                  An array of base64 encoded Merkle Tree nodes proving the inclusion of the chosen certificate.
                </t>
                <t hangText="sth:">
                  A base64 encoded SignedTreeHead.
                </t>
                <t hangText="consistency:">
                  An array of base64 encoded Merkle Tree nodes proving the consistency of the requested STH and the returned STH.
                </t>
              </list>
            </t>
            <t>
              Note that no signature is required for the <spanx style="verb">leaf_index</spanx>, <spanx style="verb">audit_path</spanx> or <spanx style="verb">consistency</spanx> outputs as they are used to verify inclusion in and consistency of <spanx style="verb">sth</spanx>, which is signed.
            </t>
          </list>
        </t>
        <t>
          Errors are the same as in <xref target="fetch_proof"/>.
        </t>
        <t>See <xref target="verify_inclusion" /> for an outline of how to use the <spanx style="verb">audit_path</spanx> array and see <xref target="verify_consistency" /> for an outline of how to use the <spanx style="verb">consistency</spanx> array.</t>
      </section>

      <section title="Retrieve Entries and STH from Log" anchor="fetch_entries">
        <t>
          GET https://&lt;log server&gt;/ct/v2/get-entries
        </t>
        <t>
          <list style="hanging">
            <t hangText="Inputs:">
              <list style="hanging">
                <t hangText="start:">
                  0-based index of first entry to retrieve, in decimal.
                </t>
                <t hangText="end:">
                  0-based index of last entry to retrieve, in decimal.
                </t>
              </list>
            </t>
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="entries:">
                  An array of objects, each consisting of
                  <list style="hanging">
                    <t hangText="leaf_input:">
                      The base64 encoded MerkleTreeLeaf structure.
                    </t>
                    <t hangText="extra_data:">
                      The base64 encoded unsigned data pertaining to the log entry. In the case of an X509ChainEntry, this is the whole <spanx style="verb">X509ChainEntry</spanx>. In the case of a PrecertChainEntryV2, this is the whole <spanx style="verb">PrecertChainEntryV2</spanx>.
                    </t>
                    <t hangText="sct:">
                      A base64 encoded <spanx style="verb">SignedCertificateTimestamp</spanx> for this entry. Note that more than one SCT may have been returned for the same entry - only one of those is returned in this field. It may not be possible to retrieve others.
                    </t>
                  </list>
                </t>
                <t hangText="sth:">
                  A base64 encoded SignedTreeHead.
                </t>
              </list>
            </t>
          </list>
        </t>
        <t>
          Note that this message is not signed -- the <spanx style="verb">entries</spanx> data can be
verified by constructing the Merkle Tree Hash corresponding to a retrieved
STH. All leaves MUST be v1 or v2. However, a compliant v1 client MUST NOT construe an
unrecognized LogEntryType value as an error. This means it
may be unable to parse some entries, but note that each client can inspect the
entries it does recognize as well as verify the integrity of the data by
treating unrecognized leaves as opaque input to the tree.
        </t>
        <t>
          The <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx> parameters SHOULD be within the range 0 &lt;= x &lt; <spanx style="verb">tree_size</spanx> as returned by <spanx style="verb">get-sth</spanx> in <xref target="fetch_sth"/>.
        </t>
        <t>
          The <spanx style="verb">start</spanx> parameter MUST be less than or equal to the <spanx style="verb">end</spanx> parameter.
        </t>
        <t>
          Log servers MUST honor requests where 0 &lt;= <spanx style="verb">start</spanx> &lt; <spanx style="verb">tree_size</spanx> and <spanx style="verb">end</spanx> &gt;= <spanx style="verb">tree_size</spanx> by returning a partial response covering only the valid entries in the specified range. <spanx style="verb">end</spanx> &gt;= <spanx style="verb">tree_size</spanx> could be caused by skew. Note that the following restriction may also apply:
        </t>
        <t>
          Logs MAY restrict the number of entries that can be retrieved per
<spanx style="verb">get-entries</spanx> request.  If a client requests more
than the permitted number of entries, the log SHALL return the maximum number
of entries permissible. These entries SHALL be sequential beginning with the
entry specified by <spanx style="verb">start</spanx>.
        </t>
        <t>
          Because of skew, it is possible the log server will not have any entries between <spanx style="verb">start</spanx> and <spanx style="verb">end</spanx>. In this case it MUST return an empty <spanx style="verb">entries</spanx> array.
        </t>
        <t>
          In any case, the log server MUST return the latest STH it knows about.
        </t>
        <t>See <xref target="verify_hash" /> for an outline of how to use a complete list of <spanx style="verb">leaf_input</spanx> entries to verify the <spanx style="verb">root_hash</spanx>.</t>
      </section>

      <section title="Retrieve Accepted Root Certificates">
        <t>
          GET https://&lt;log server&gt;/ct/v1/get-roots
        </t>
        <t>
          No inputs.
        </t>
        <t>
          <list style="hanging">
            <t hangText="Outputs:">
              <list style="hanging">
                <t hangText="certificates:">
                  An array of base64 encoded root certificates that are acceptable to the log.
                </t>
                <t hangText="max_chain:">
                  If the server has chosen to limit the length of chains it accepts, this is the maximum number of certificates in the chain, in decimal. If there is no limit, this is omitted.
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Clients">
      <t>
        There are various different functions clients of logs might perform. We
describe here some typical clients and how they should function. Any
inconsistency may be used as evidence that a log has not behaved correctly, and
the signatures on the data structures prevent the log from denying that
misbehavior.
      </t>
      <t>
        All clients need various metadata in order to communicate with logs and verify their responses. This metadata is described below, but note that this document does not describe how the metadata is obtained, which is implementation dependent (see, for example, <xref target="Chromium.Policy"/>).
      </t>
      <t>
        Clients should somehow exchange STHs they see, or make them
available for scrutiny, in order to ensure that they all have a
consistent view. The exact mechanisms will be in separate documents,
but it is expected there will be a variety.
      </t>
      <section title="Metadata" anchor="metadata">
        <t>
          In order to communicate with and verify a log, clients need metadata about the log.
        </t>
        <t><list style="hanging">
          <t hangText="Base URL:">
            The URL to substitute for &lt;log server&gt; in <xref target="client_messages"/>.
          </t>
          <t hangText="Hash Algorithm">
            The hash algorithm used for the Merkle Tree (see <xref target="hash_algorithms"/>).
          </t>
          <t hangText="Signing Algorithm">
            The signing algorithm used (see <xref target="signatures"/>).
          </t>
          <t hangText="Public Key">
            The public key used for signing.
          </t>
          <t hangText="Maximum Merge Delay">
            The MMD the log has committed to.
          </t>
          <t hangText="Version">
            The version of the protocol supported by the log (currently 1 or 2).
          </t>
          <t hangText="Maximum Chain Length">
            The longest chain submission the log is willing to accept, if the log chose to limit it.
          </t>
          <t hangText="STH Frequency Count">
            The maximum number of STHs the log may produce in any period equal to the <spanx style="verb">Maximum Merge Delay</spanx> (see <xref target="STH"/>).
          </t>
          <t hangText="Final STH">
            If a log has been closed down (i.e. no longer accepts new entries), existing entries may still be valid. In this case, the client should know the final valid STH in the log to ensure no new entries can be added without detection.
          </t>
        </list></t>
        <t>
          <xref target="JSON.Metadata"/> is an example of a metadata format which includes the above elements.
        </t>
      </section>
      <section title="Submitters">
        <t>
          Submitters submit certificates or precertificates to the log as described above. When a Submitter intends to use the returned SCT directly in a TLS handshake or to construct a certificate, they SHOULD validate the SCT as described in <xref target="tls_clients"/> if they understand its format.
        </t>
      </section>
      <section title="TLS Client" anchor="tls_clients">
        <t>
          TLS clients receive SCTs alongside or in certificates, either for the server certificate itself or for intermediate CA precertificates. In
addition to normal validation of the certificate and its chain, TLS clients
SHOULD validate the SCT by computing the signature input from the SCT data as
well as the certificate and verifying the signature, using the corresponding
log's public key. By validating SCTs, TLS clients can thus determine whether certificates are compliant. However, specifying the TLS clients' behaviour once compliance or non-compliance has been determined (for example, whether a certificate should be rejected due to the lack of valid SCTs) is outside the scope of this document.
        </t>
        <t>
          A TLS client MAY audit the corresponding log by requesting, and
          verifying, a Merkle audit proof for said certificate.
          If the TLS client holds an STH that predates the SCT, it MAY, in the process of auditing, request a new STH from the log (<xref target="fetch_sth"/>), then verify it by requesting a consistency proof (<xref target="fetch_consistency"/>).
        </t>
        <t>
          TLS clients MUST reject SCTs whose timestamp is in the future.
        </t>
      </section>
      <section title="Monitor" anchor="monitor">
        <t>
          Monitors watch logs and check that they behave correctly. Monitors may additionally watch for certificates of interest. For example, a monitor may be configured to report on all certificates that apply to a specific domain name when fetching new entries for consistency validation.
        </t>
        <t>
          A monitor needs to, at least, inspect every new entry in each log it watches. It may also want to keep copies of entire logs. In order to do this, it should follow these steps for each log:
          <list style="numbers">
            <t>
              Fetch the current STH (<xref target="fetch_sth"/>).
            </t>
            <t>
              Verify the STH signature.
            </t>
            <t>
              Fetch all the entries in the tree corresponding to the STH (<xref target="fetch_entries"/>).
            </t>
            <t>
              Confirm that the tree made from the fetched entries produces the same hash as that in the STH.
            </t>
            <t anchor="monitor_loop">
              Fetch the current STH (<xref target="fetch_sth"/>). Repeat until
the STH changes.
            </t>
            <t>
              Verify the STH signature.
            </t>
            <t>
              Fetch all the new entries in the tree corresponding to the STH
(<xref target="fetch_entries"/>). If they remain unavailable for an extended period, then this should be viewed as misbehavior on the part of the log.
            </t>
            <t>
              Either:
              <list style="numbers">
                <t>
                  Verify that the updated list of all entries generates a tree with the same hash as the new STH.
                </t>
              </list>
              Or, if it is not keeping all log entries:
              <list style="numbers">
                <t>
                  Fetch a consistency proof for the new STH with the previous STH (<xref target="fetch_consistency"/>).
                </t>
                <t>
                  Verify the consistency proof.
                </t>
                <t>
                  Verify that the new entries generate the corresponding elements in the consistency proof.
                </t>
              </list>
            </t>
            <t>
              Go to Step 5.
            </t>
          </list>
        </t>
      </section>
      <section title="Auditing">
        <t>
          Auditing is taking partial information about a log as input and verifying that this information is consistent with other partial information held. All clients described above may perform auditing as an additional function. The action taken by the client if audit fails is not specified, but note that in general if audit fails, the client is in possession of signed proof of the log's misbehavior.
        </t>
        <t>
          A <xref target="monitor">monitor</xref> can audit by verifying the consistency of STHs it receives, ensure that each entry can be fetched and that the STH is indeed the result of making a tree from all fetched entries.
        </t>
        <t>
          A <xref target="tls_clients">TLS client</xref> can audit by verifying an SCT against any STH dated after the SCT timestamp + the Maximum Merge Delay by requesting a Merkle inclusion proof (<xref target="fetch_proof"/>). It can also verify that the SCT corresponds to the certificate it arrived with (i.e. the log entry is that certificate, is a precertificate for that certificate or is an appropriate name-constrained intermediate [see <xref target="name_constrained"/>]).
        </t>
        <t>
          The following algorithm outlines may be useful for clients that wish to perform various audit operations.
        </t>
        <section title="Verifying an inclusion proof" anchor="verify_inclusion">
          <t>
            When a client has received an <spanx style="verb">audit_path</spanx> and <spanx style="verb">leaf_index</spanx> and wishes to verify inclusion of an input <spanx style="verb">hash</spanx> for an STH with a given <spanx style="verb">tree_size</spanx> and <spanx style="verb">root_hash</spanx>, the following algorithm may be used to prove the <spanx style="verb">hash</spanx> was included in the <spanx style="verb">root_hash</spanx>:
            <list style="numbers">
              <t>Set <spanx style="verb">fn</spanx> to <spanx style="verb">leaf_index</spanx> and <spanx style="verb">sn</spanx> to <spanx style="verb">tree_size - 1</spanx>.</t>
              <t>Set <spanx style="verb">r</spanx> to <spanx style="verb">hash</spanx>.</t>
              <t>
                For each value <spanx style="verb">p</spanx> in the <spanx style="verb">audit_path</spanx> array:
                <vspace blankLines="1" />
                If <spanx style="verb">LSB(fn)</spanx> is set, or if <spanx style="verb">fn</spanx> is equal to <spanx style="verb">sn</spanx>, then:
                <list style="numbers">
                  <t>
                    Set <spanx style="verb">r</spanx> to <spanx style="verb">HASH(0x01 || p || r)</spanx>
                  </t>
                  <t>If <spanx style="verb">LSB(fn)</spanx> is not set, then right-shift both <spanx style="verb">fn</spanx> and <spanx style="verb">sn</spanx> equally until either <spanx style="verb">LSB(fn)</spanx> is set or <spanx style="verb">fn</spanx> is <spanx style="verb">0</spanx>.</t>
                </list>
                Otherwise:
                <list style="empty">
                  <t>Set <spanx style="verb">r</spanx> to <spanx style="verb">HASH(0x01 || r || p)</spanx></t>
                </list>
                <vspace blankLines="1" />
                Finally, right-shift both <spanx style="verb">fn</spanx> and <spanx style="verb">sn</spanx> one time.
              </t>
              <t>Compare <spanx style="verb">r</spanx> against the <spanx style="verb">root_hash</spanx>. If they are equal, then the log has proven the inclusion of <spanx style="verb">hash</spanx>.</t>
            </list>
          </t>
        </section>
        <section title="Verifying consistency between two STHs" anchor="verify_consistency">
          <t>
            When a client has an STH <spanx style="verb">first_hash</spanx> for tree size <spanx style="verb">first</spanx>, an STH <spanx style="verb">second_hash</spanx> for tree size <spanx style="verb">second</spanx> where <spanx style="verb">0 &lt; first &lt; second</spanx>, and has received a <spanx style="verb">consistency</spanx> array that they wish to use to verify both hashes, the following algorithm may be used:
            <list style="numbers">
              <t>If <spanx style="verb">first</spanx> is an exact power of 2, then prepend <spanx style="verb">first_hash</spanx> to the <spanx style="verb">consistency</spanx> array.</t>
              <t>Set <spanx style="verb">fn</spanx> to <spanx style="verb">first - 1</spanx> and <spanx style="verb">sn</spanx> to <spanx style="verb">second - 1</spanx>.</t>
              <t>If <spanx style="verb">LSB(fn)</spanx> is set, then right-shift both <spanx style="verb">fn</spanx> and <spanx style="verb">sn</spanx> equally until <spanx style="verb">LSB(fn)</spanx> is not set.</t>
              <t>Set both <spanx style="verb">fr</spanx> and <spanx style="verb">sr</spanx> to the first value in the <spanx style="verb">consistency</spanx> array.</t>
              <t>
                For each subsequent value <spanx style="verb">c</spanx> in the <spanx style="verb">consistency</spanx> array:
                <vspace blankLines="1" />
                If <spanx style="verb">LSB(fn)</spanx> is set, or if <spanx style="verb">fn</spanx> is equal to <spanx style="verb">sn</spanx>, then:
                <list style="numbers">
                  <t>
                    Set <spanx style="verb">fr</spanx> to <spanx style="verb">HASH(0x01 || c || fr)</spanx>
                    <vspace blankLines="0" />
                    Set <spanx style="verb">sr</spanx> to <spanx style="verb">HASH(0x01 || c || sr)</spanx>
                  </t>
                  <t>If <spanx style="verb">LSB(fn)</spanx> is not set, then right-shift both <spanx style="verb">fn</spanx> and <spanx style="verb">sn</spanx> equally until either <spanx style="verb">LSB(fn)</spanx> is set or <spanx style="verb">fn</spanx> is <spanx style="verb">0</spanx>.</t>
                </list>
                Otherwise:
                <list style="empty">
                  <t>Set <spanx style="verb">sr</spanx> to <spanx style="verb">HASH(0x01 || sr || c)</spanx></t>
                </list>
                <vspace blankLines="1" />
                Finally, right-shift both <spanx style="verb">fn</spanx> and <spanx style="verb">sn</spanx> one time.
              </t>
              <t>After completing iterating through the <spanx style="verb">consistency</spanx> array as described above, verify that the <spanx style="verb">fr</spanx> calculated is equal to the <spanx style="verb">first_hash</spanx> supplied and that the <spanx style="verb">sr</spanx> calculated is equal to the <spanx style="verb">second_hash</spanx> supplied.</t>
            </list>
          </t>
        </section>
        <section title="Verifying root hash given entries" anchor="verify_hash">
          <t>
            When a client has a complete list of leaf input <spanx style="verb">entries</spanx> from <spanx style="verb">0</spanx> up to <spanx style="verb">tree_size - 1</spanx> and wishes to verify this list against an STH <spanx style="verb">root_hash</spanx> returned by the log for the same <spanx style="verb">tree_size</spanx>, the following algorithm may be used:
            <list style="numbers">
              <t>Set <spanx style="verb">stack</spanx> to an empty stack.</t>
              <t>
                 For each <spanx style="verb">i</spanx> from <spanx style="verb">0</spanx> up to <spanx style="verb">tree_size - 1</spanx>:
                 <list style="numbers">
                   <t>Push <spanx style="verb">HASH(0x00 || entries[i])</spanx> to <spanx style="verb">stack</spanx>.</t>
                   <t>Set <spanx style="verb">merge_count</spanx> to the lowest value (<spanx style="verb">0</spanx> included) such that <spanx style="verb">LSB(i >> merge_count)</spanx> is not set.  In other words, set <spanx style="verb">merge_count</spanx> to the number of consecutive <spanx style="verb">1</spanx>s found starting at the least significant bit of <spanx style="verb">i</spanx>.</t>
                   <t>
                     Repeat <spanx style="verb">merge_count</spanx> times:
                     <list style="numbers">
                       <t>Pop <spanx style="verb">right</spanx> from <spanx style="verb">stack</spanx>.</t>
                       <t>Pop <spanx style="verb">left</spanx> from <spanx style="verb">stack</spanx>.</t>
                       <t>Push <spanx style="verb">HASH(0x01 || left || right)</spanx> to <spanx style="verb">stack</spanx>.</t>
                     </list>
                   </t>
                 </list>
               </t>
               <t>If there is more than one element in the <spanx style="verb">stack</spanx>, repeat the same merge procedure (Step 2.3 above) until only a single element remains.</t>
               <t>The remaining element in <spanx style="verb">stack</spanx> is the Merkle Tree hash for the given <spanx style="verb">tree_size</spanx> and should be compared by equality against the supplied <spanx style="verb">root_hash</spanx>.</t>
            </list>
          </t>
        </section>
      </section>
    </section>

    <section title="Algorithm Agility">
      <t>
        It is not possible for a log to change any of its algorithms part way through its lifetime. If it should become necessary to deprecate an algorithm used by a live log, then the log should be frozen as specified in <xref target="metadata"/> and a new log should be started. If necessary, the new log can contain existing entries from the frozen log, which monitors can verify are an exact match.
      </t>
    </section>

    <section title="IANA Considerations">
      <section title="TLS Extension Type">
        <t>
          IANA has allocated an RFC 5246 ExtensionType value (18) for the SCT TLS extension. The extension name is "signed_certificate_timestamp". IANA should update this extension type to point at this document.
        </t>
      </section>
      <section title="Hash Algorithms" anchor="hash_algorithms">
        <t>
          IANA is asked to establish a registry of hash values, initially consisting of:
        </t>
        <texttable>
          <ttcol>Index</ttcol><ttcol>Hash</ttcol>
          <c>0</c><c><xref target="FIPS.180-4">SHA-256</xref></c>
        </texttable>
        </section>
      <section title="SCT Extensions" anchor="sct_extension_types">
        <t>
          IANA is asked to establish a registry of SCT extensions, initially consisting of:
        </t>
        <texttable>
          <ttcol>Type</ttcol><ttcol>Extension</ttcol>
          <c>65535</c><c>reserved</c>
        </texttable>
        <t>
          TBD: policy for adding to the registry
        </t>
      </section>
      <section title="STH Extensions" anchor="sth_extension_types">
        <t>
          IANA is asked to establish a registry of STH extensions, initially consisting of:
        </t>
        <texttable>
          <ttcol>Type</ttcol><ttcol>Extension</ttcol>
          <c>65535</c><c>reserved</c>
        </texttable>
        <t>
          TBD: policy for adding to the registry
        </t>
      </section>
    </section>

    <section title="Security Considerations">
      <t>
        With CAs, logs, and servers performing the actions described here, TLS clients can use logs and signed timestamps to reduce the likelihood that they will accept misissued certificates.  If a server presents a valid signed timestamp for a certificate, then the client knows that a log has committed to publishing the certificate.  From this, the client knows that the subject of the certificate has had some time to notice the misissue and take some action, such as asking a CA to revoke a misissued certificate, or that the log has misbehaved, which will be discovered when the SCT is audited.  A signed timestamp is not a guarantee that the certificate is not misissued, since the subject of the certificate might not have checked the logs or the CA might have refused to revoke the certificate.
      </t>
      <t>
        In addition, if TLS clients will not accept unlogged certificates, then site owners will have a greater incentive to submit certificates to logs, possibly with the assistance of their CA, increasing the overall transparency of the system.
      </t>
      <section title="Misissued Certificates">
        <t>
          Misissued certificates that have not been publicly logged, and thus do not have a valid SCT, are not considered compliant (so TLS clients may decide, for example, to reject them). Misissued certificates that do have an SCT from a log will appear in that public log within the Maximum Merge Delay, assuming the log is operating correctly. Thus, the maximum period of time during which a misissued certificate can be used without being available for audit is the MMD.
        </t>
      </section>
      <section title="Detection of Misissue">
        <t>
          The logs do not themselves detect misissued certificates; they rely
instead on interested parties, such as domain owners, to monitor them and take
corrective action when a misissue is detected.
        </t>
      </section>
      <section title="Redaction of Public Domain Name Labels">
        <t>
          CAs SHOULD NOT redact domain name labels in precertificates such that the entirety of the domain space below the unredacted part of the domain name is not owned or controlled by a single entity
(e.g. <spanx style="verb">?.com</spanx> and
<spanx style="verb">?.co.uk</spanx> would both be problematic). Logs
MUST NOT reject any precertificate that is overly redacted but which is
otherwise considered compliant. It is expected that monitors will treat overly
redacted precertificates as potentially misissued. TLS clients MAY reject a
certificate whose corresponding precertificate would be overly redacted, perhaps using the same mechanism for determining whether a wildcard in a domain name of a certificate is too broad.
        </t>
      </section>
      <section title="Misbehaving Logs">
        <t>
          A log can misbehave in two ways: (1) by failing to incorporate a
certificate with an SCT in the Merkle Tree within the MMD and (2) by
violating its append-only property by presenting two different, conflicting
views of the Merkle Tree at different times and/or to different parties. Both
forms of violation will be promptly and publicly detectable.
        </t>
        <t>
          Violation of the MMD contract is detected by log clients requesting a
Merkle audit proof for each observed SCT. These checks can be asynchronous and
need only be done once per each certificate. In order to protect the clients'
privacy, these checks need not reveal the exact certificate to the log. Clients
can instead request the proof from a trusted auditor (since anyone can compute
the audit proofs from the log) or request Merkle proofs for a batch of
certificates around the SCT timestamp.
        </t>
        <t>
          Violation of the append-only property can be detected by clients comparing their instances of the Signed Tree Heads. As soon as two conflicting Signed Tree Heads for the same log are detected, this is cryptographic proof of that log's misbehavior. There are various ways this could be done, for example via gossip (see http://trac.tools.ietf.org/id/draft-linus-trans-gossip-00.txt) or peer-to-peer communications or by sending STHs to monitors (who could then directly check against their own copy of the relevant log).
        </t>
      </section>
      <section title="Multiple SCTs">
        <t>
          TLS servers may wish to offer multiple SCTs, each from a different log.
          <list style="symbols">
            <t>
              If a CA and a log collude, it is possible to temporarily hide misissuance from clients. Including SCTs from different logs makes it more difficult to mount this attack.
            </t>
            <t>
              If a log misbehaves, a consequence may be that clients cease to trust it. Since the time an SCT may be in use can be considerable (several years is common in current practice when the SCT is embedded in a certificate), servers may wish to reduce the probability of their certificates being rejected as a result by including SCTs from different logs.
            </t>
            <t>
              TLS clients may have policies related to the above risks requiring servers to present multiple SCTs. For example <xref target="Chromium.Log.Policy">Chromium</xref> currently requires multiple SCTs to be presented with EV certificates in order for the EV indicator to be shown.
            </t>
          </list>
        </t>
      </section>
    </section>
    <section title="Efficiency Considerations">
      <t>
        The Merkle Tree design serves the purpose of keeping communication overhead low.
      </t>
      <t>
        Auditing logs for integrity does not require third parties to maintain a copy of each entire log. The Signed Tree Heads can be updated as new entries become available, without recomputing entire trees. Third-party auditors need only fetch the Merkle consistency proofs against a log's existing STH to efficiently verify the append-only property of updates to their Merkle Trees, without auditing the entire tree.
      </t>
    </section>
    <section title="Acknowledgements">
      <t>
        The authors would like to thank Erwann Abelea, Robin Alden, Al Cutter,
Francis Dupont, Adam Eijdenberg, Stephen Farrell, Daniel Kahn Gillmor, Brad Hill, Jeff Hodges, Paul Hoffman, Jeffrey Hutzelman, Stephen Kent, SM, Alexey Melnikov, Linus Nordberg, Chris Palmer, Trevor Perrin, Pierre Phaneuf, Melinda Shore, Ryan Sleevi, Carl Wallace and Paul Wouters for their valuable contributions.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">

      <?rfc include="reference.RFC.2119" ?>

      <?rfc include="reference.RFC.2616"?>

      <?rfc include="reference.RFC.3447"?>

      <?rfc include="reference.RFC.4627"?>

      <?rfc include="reference.RFC.4648"?>

      <?rfc include="reference.RFC.5246"?>

      <?rfc include="reference.RFC.5280"?>

      <?rfc include="reference.RFC.5652"?>

      <?rfc include="reference.RFC.5905"?>

      <?rfc include="reference.RFC.6066"?>

      <?rfc include="reference.RFC.6125"?>

      <?rfc include="reference.RFC.6960"?>

      <?rfc include="reference.RFC.6979"?>

      <reference anchor="DSS" target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf">
        <front>
          <title>Digital Signature Standard (DSS)</title>
          <author>
            <organization abbrev="NIST">National Institute of Standards and
Technology</organization>
          </author>
          <date month="June" year="2009"/>
        </front>
        <seriesInfo name="FIPS" value="186-3"/>
        <format type="PDF" target="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf"/>
      </reference>

      <reference anchor="FIPS.180-4"
target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
        <front>
          <title>Secure Hash Standard</title>
          <author>
            <organization>National Institute of Standards and Technology</organization>
          </author>
          <date month="March" year="2012"/>
        </front>
        <seriesInfo name="FIPS" value="PUB 180-4"/>
      </reference>

      <reference anchor="HTML401" target="http://www.w3.org/TR/1999/REC-html401-19991224">
        <front>
          <title>HTML 4.01 Specification</title>
          <author initials="D." surname="Raggett" fullname="David Raggett">
            <organization/>
          </author>
          <author initials="A." surname="Le Hors" fullname="Arnaud Le Hors">
            <organization/>
          </author>
          <author initials="I." surname="Jacobs" fullname="Ian Jacobs">
            <organization/>
          </author>
          <date month="December" day="24" year="1999"/>
        </front>
        <seriesInfo name="World Wide Web Consortium Recommendation" value="REC-html401-19991224"/>
        <format type="HTML" target="http://www.w3.org/TR/1999/REC-html401-19991224"/>
      </reference>

    </references>

<references title="Informative References">

    <?rfc include="reference.RFC.6962"?>

      <reference anchor="CrosbyWallach"
target="http://static.usenix.org/event/sec09/tech/full_papers/crosby.pdf">
        <front>
          <title>Efficient Data Structures for Tamper-Evident Logging</title>
          <author initials='S.' surname='Crosby' fullname='Scott A. Crosby'>
            <organization/>
          </author>
          <author initials='D.' surname='Wallach' fullname='Dan S. Wallach'>
            <organization/>
          </author>
          <date month="August" year="2009"/>
        </front>
<seriesInfo name="Proceedings of the 18th USENIX Security Symposium,"
value="Montreal"/>
        <format type="PDF" target="http://static.usenix.org/event/sec09/tech/full_papers/crosby.pdf"/>
      </reference>

      <reference anchor="EVSSLGuidelines" target="https://cabforum.org/wp-content/uploads/EV_Certificate_Guidelines.pdf">
        <front>
          <title>Guidelines For The Issuance And Management Of Extended Validation Certificates</title>
          <author>
            <organization>CA/Browser Forum</organization>
          </author>
          <date year="2007"/>
        </front>
        <format type="PDF" target="https://cabforum.org/wp-content/uploads/EV_Certificate_Guidelines.pdf"/>
      </reference>

      <reference anchor="Chromium.Policy" target="http://www.chromium.org/Home/chromium-security/certificate-transparency">
        <front>
          <title>Chromium Certificate Transparency</title>
          <author>
            <organization>The Chromium Projects</organization>
          </author>
          <date year="2014"/>
        </front>
      </reference>

      <reference anchor="JSON.Metadata" target="http://www.certificate-transparency.org/known-logs/log_list_schema.json">
        <front>
          <title>Chromium Log Metadata JSON Schema</title>
          <author>
            <organization>The Chromium Projects</organization>
          </author>
          <date year="2014"/>
        </front>
      </reference>

      <reference anchor="Chromium.Log.Policy" target="http://www.chromium.org/Home/chromium-security/certificate-transparency/log-policy">
        <front>
          <title>Chromium Certificate Transparency Log Policy</title>
          <author>
            <organization>The Chromium Projects</organization>
          </author>
          <date year="2014"/>
        </front>
      </reference>

    </references>
  </back>
</rfc>
